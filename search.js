window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "aol", "modulename": "aol", "type": "module", "doc": "<h1 id=\"module-aol\">Module \"AOL\"</h1>\n\n<p>This module contains the classes that implement the AOL logs and the serialization of these\nas file.</p>\n\n<ul>\n<li><strong>append_only_log.py:</strong>\nThe class that represents the log and associated methods without the structure of the entries.</li>\n<li><strong>append_only_log_entry.py:</strong>\nThe class that represents one entry</li>\n</ul>\n"}, {"fullname": "aol.append_only_log", "modulename": "aol.append_only_log", "type": "module", "doc": "<p>Implementation of the class that represents an append-only log within a peer node. It is based on the\nAOLSingleton metaclass.</p>\n"}, {"fullname": "aol.append_only_log.AppendOnlyLog", "modulename": "aol.append_only_log", "qualname": "AppendOnlyLog", "type": "class", "doc": "<p>This class represents an append only log (AOL). It's decorated with the serializer in order de-serialize from/into\njson and send it over a connection. The constructor should never be used directly. It is reserved for the\nserializer, to ensure atomicity. Instead, factory methods are provided. Within one node, only one instance of a\nparticular AOL can exist. Thus, the AOL is a singleton that is implemented using the AOLSingleton metaclass.</p>\n\n<p>This class also implements writing/reading the AOL to/from disk. A log consists of 2 files, an index file and\na file containing the actual content. The basename is the UUID assigned to the log.</p>\n\n<ul>\n<li>index file <uuid>.idx\n<ul>\n<li>it consists of binary records of 4 bytes each representing an integer (big endian format)</li>\n<li>the first record contains the ttl (time to live) the log has on this peer</li>\n<li>the next records contain the starting bytes of the data records which are stored in the data file</li>\n</ul></li>\n<li>data file <uuid>.log\n<ul>\n<li>the first 4 bytes contain the length of the entry metadata (as integer, big endian) which is stored a json</li>\n<li>then the json strings added (length as above)</li>\n<li>the next 4 bytes contain the length of the payload (as integer, big endian)</li>\n<li>then the payload is added (length given above) as binary blob (bytes)</li>\n</ul></li>\n</ul>\n"}, {"fullname": "aol.append_only_log.AppendOnlyLog.__init__", "modulename": "aol.append_only_log", "qualname": "AppendOnlyLog.__init__", "type": "function", "doc": "<p>This constructor should <em>never</em> be used directly. It's only used by the serializer. Otherwise, the\nclassmethods \"AppendOnlyLog.create_new_log()\" or \"AppendOnlyLog.from_disk()\" must be used!</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>log_id</strong>:  UUID of the AOL as str</li>\n<li><strong>ttl</strong>:  Time to live of the AOL (range/horizon)</li>\n<li><strong>log_creation_timestamp</strong>:  Creation timestamp</li>\n<li><strong>title</strong>:  Title of the log</li>\n<li><strong>description</strong>:  Very brief description of the expected content</li>\n<li><strong>creator</strong>:  Creator of the AOL</li>\n<li><strong>length</strong>:  Length of the AOL. (Number of Entries inside this AOL)</li>\n</ul>\n", "signature": "(\n    self,\n    *,\n    log_id: str,\n    ttl: int,\n    log_creation_timestamp: str,\n    title: str,\n    description: str,\n    creator: str,\n    length: Optional[int] = 0\n)", "funcdef": "def"}, {"fullname": "aol.append_only_log.AppendOnlyLog.get_all_logs_on_disk", "modulename": "aol.append_only_log", "qualname": "AppendOnlyLog.get_all_logs_on_disk", "type": "function", "doc": "<p>Factory method. Reads all logs from the disc and returns a dict with the log id as key and the log instance as value. It's a static method\nsince it is called when there is not an instance yet of any AOL.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A dict with the log id as key and the log instance as value.</p>\n</blockquote>\n", "signature": "() -> Dict[str, aol.append_only_log.AppendOnlyLog]", "funcdef": "def"}, {"fullname": "aol.append_only_log.AppendOnlyLog.create_new_log", "modulename": "aol.append_only_log", "qualname": "AppendOnlyLog.create_new_log", "type": "function", "doc": "<p>Factory method. Creates a new log on the disc/storage and returns the resulting AOL instance</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ttl</strong>:  Time to live</li>\n<li><strong>title</strong>:  Title of the log</li>\n<li><strong>description</strong>:  Very brief description of the expected content</li>\n<li><strong>creator</strong>:  Creator of the AOL</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>New AOL instance</p>\n</blockquote>\n", "signature": "(\n    cls,\n    ttl: int,\n    title: str,\n    description: str,\n    creator: str\n) -> aol.append_only_log.AppendOnlyLog", "funcdef": "async def"}, {"fullname": "aol.append_only_log.AppendOnlyLog.from_disk", "modulename": "aol.append_only_log", "qualname": "AppendOnlyLog.from_disk", "type": "function", "doc": "<p>Factory method. Reads a log from the storage/disc and returns the corresponding AOL instance</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>log_id</strong>:  The UUID of the log that is to be read</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The AOL instance of the requested AOL</p>\n</blockquote>\n", "signature": "(cls, log_id: str) -> aol.append_only_log.AppendOnlyLog", "funcdef": "def"}, {"fullname": "aol.append_only_log.AppendOnlyLog.len_from_disk", "modulename": "aol.append_only_log", "qualname": "AppendOnlyLog.len_from_disk", "type": "function", "doc": "<p>Returns the number of log entries in the (disk) log</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>number of entries</p>\n</blockquote>\n", "signature": "(self) -> int", "funcdef": "def"}, {"fullname": "aol.append_only_log.AppendOnlyLog.log_id", "modulename": "aol.append_only_log", "qualname": "AppendOnlyLog.log_id", "type": "variable", "doc": "<p>Getter for log_id</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>log_id</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "aol.append_only_log.AppendOnlyLog.ttl", "modulename": "aol.append_only_log", "qualname": "AppendOnlyLog.ttl", "type": "variable", "doc": "<p>Getter for ttl</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>ttl</p>\n</blockquote>\n", "annotation": ": int"}, {"fullname": "aol.append_only_log.AppendOnlyLog.decr_ttl", "modulename": "aol.append_only_log", "qualname": "AppendOnlyLog.decr_ttl", "type": "function", "doc": "<p>Decrements the ttl of an AOL by 1</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "aol.append_only_log.AppendOnlyLog.title", "modulename": "aol.append_only_log", "qualname": "AppendOnlyLog.title", "type": "variable", "doc": "<p>Getter for title</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>title</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "aol.append_only_log.AppendOnlyLog.description", "modulename": "aol.append_only_log", "qualname": "AppendOnlyLog.description", "type": "variable", "doc": "<p>Getter for description</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>description</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "aol.append_only_log.AppendOnlyLog.update_ttl", "modulename": "aol.append_only_log", "qualname": "AppendOnlyLog.update_ttl", "type": "function", "doc": "<p>Updates the ttl on the disc to the ttl given as parameter. This function is needed, if a connection between two peers gets closer if e.g. a\nnew shorter route through the follower network has been found.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ttl</strong>:  The new ttl</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self, ttl: int) -> None", "funcdef": "def"}, {"fullname": "aol.append_only_log.AppendOnlyLog.create_disk_log", "modulename": "aol.append_only_log", "qualname": "AppendOnlyLog.create_disk_log", "type": "function", "doc": "<p>This methode creates the logfiles and optionally - if given - adds the entries</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>entries</strong>:  [Optional] Entries to be written into the newly created disk log</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    self,\n    entries: Optional[List[aol.append_only_log_entry.AppendOnlyLogEntry]] = None\n) -> None", "funcdef": "async def"}, {"fullname": "aol.append_only_log.AppendOnlyLog.append_new_logentry", "modulename": "aol.append_only_log", "qualname": "AppendOnlyLog.append_new_logentry", "type": "function", "doc": "<p>Appends a new entry given by payload and mimetype to the log.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>payload</strong>:  The payload of the entry</li>\n<li><strong>mimetype</strong>:  the data-type of the payload</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>AppendOnlyLogEntry instance of the newly created entry</p>\n</blockquote>\n", "signature": "(\n    self,\n    payload: bytes,\n    mimetype: str\n) -> aol.append_only_log_entry.AppendOnlyLogEntry", "funcdef": "async def"}, {"fullname": "aol.append_only_log.AppendOnlyLog.append_copy_logentries", "modulename": "aol.append_only_log", "qualname": "AppendOnlyLog.append_copy_logentries", "type": "function", "doc": "<p>Appends a logentry to an already present log. This methode will only be called, if the entry that is to\nbe appended comes from another peer.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>entries</strong>:  List of entry instances</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    self,\n    entries: List[aol.append_only_log_entry.AppendOnlyLogEntry]\n) -> None", "funcdef": "async def"}, {"fullname": "aol.append_only_log.AppendOnlyLog.get_entries", "modulename": "aol.append_only_log", "qualname": "AppendOnlyLog.get_entries", "type": "function", "doc": "<p>Get a range of entries from the logfile. If the range given is outside the available entries, an empty list is returned.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>from_index</strong>:  Starting point from where indexes should e returned. If to_index is omitted, then only the from_index-entry is returned</li>\n<li><strong>to_index</strong>:  Exclusive endpoint of index range. If omitted, see above. If -1, all entries to the end are returned.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A list of the requested entries. See in param's for exceptions</p>\n</blockquote>\n", "signature": "(\n    self,\n    from_index: int,\n    to_index: Optional[int] = None\n) -> List[aol.append_only_log_entry.AppendOnlyLogEntry]", "funcdef": "def"}, {"fullname": "aol.append_only_log.AppendOnlyLog.creation_date", "modulename": "aol.append_only_log", "qualname": "AppendOnlyLog.creation_date", "type": "variable", "doc": "<p>Getter for creation time of log</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>creation time as string</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "aol.append_only_log.test", "modulename": "aol.append_only_log", "qualname": "test", "type": "function", "doc": "<p>Function for testing purposes. Ignore</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "()", "funcdef": "async def"}, {"fullname": "aol.append_only_log_entry", "modulename": "aol.append_only_log_entry", "type": "module", "doc": "<p>Implements the append-only log entry. These entries consist of an index identifying the position in the log, a\nmimetype that is used to identify the content data type. Also, the UUID-string of the creator is recorded. The\ncreation time is only for user informational purposes, it's not used by the algorithms</p>\n"}, {"fullname": "aol.append_only_log_entry.AppendOnlyLogEntry", "modulename": "aol.append_only_log_entry", "qualname": "AppendOnlyLogEntry", "type": "class", "doc": "<p>This class represents an append only log entry (AOL entry). It's decorated with the serializer in order de-serialize from/into json and send it\nover a connection. The constructor should never be used directly. It is reserved for the serializer, to ensure atomicity. Instead factory methods\nare provided.</p>\n"}, {"fullname": "aol.append_only_log_entry.AppendOnlyLogEntry.__init__", "modulename": "aol.append_only_log_entry", "qualname": "AppendOnlyLogEntry.__init__", "type": "function", "doc": "<p>This constructor should usually not be used directly. It is reserved for the serialized, to ensure atomicity.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>index</strong>:  The index of the entry inside an AOL</li>\n<li><strong>entry_creation_timestamp</strong>:  Creation timestamp. It's only for information purposes, but not used in\n                             connection algorithms</li>\n<li><strong>payload</strong>:  Payload of the entry. Must be bytes. Strings must be converted to bytes.</li>\n<li><strong>mimetype: The different mimetypes are</strong>:  \"text/text\", \"audio/raw\", \"audio/stream; destination=host; start|end\"</li>\n<li><strong>creator</strong>:  The creator of this entry</li>\n</ul>\n", "signature": "(\n    self,\n    index: int,\n    entry_creation_timestamp: str,\n    payload: bytes,\n    mimetype: str,\n    creator: str\n)", "funcdef": "def"}, {"fullname": "aol.append_only_log_entry.AppendOnlyLogEntry.index", "modulename": "aol.append_only_log_entry", "qualname": "AppendOnlyLogEntry.index", "type": "variable", "doc": "<p>Getter for index of log entry</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>index of log entry</p>\n</blockquote>\n", "annotation": ": int"}, {"fullname": "aol.append_only_log_entry.AppendOnlyLogEntry.entry_creation_timestamp", "modulename": "aol.append_only_log_entry", "qualname": "AppendOnlyLogEntry.entry_creation_timestamp", "type": "variable", "doc": "<p>Getter for the timestamp of the entry</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>timestamp string</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "aol.append_only_log_entry.AppendOnlyLogEntry.mimetype", "modulename": "aol.append_only_log_entry", "qualname": "AppendOnlyLogEntry.mimetype", "type": "variable", "doc": "<p>Getter for the mimetype</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>mimetype string</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "aol.append_only_log_entry.AppendOnlyLogEntry.creator", "modulename": "aol.append_only_log_entry", "qualname": "AppendOnlyLogEntry.creator", "type": "variable", "doc": "<p>Getter for the creater UUID string</p>\n\n<h6 id=\"returns\">Returns</h6>\n"}, {"fullname": "aol.append_only_log_entry.AppendOnlyLogEntry.size", "modulename": "aol.append_only_log_entry", "qualname": "AppendOnlyLogEntry.size", "type": "variable", "doc": "<p>Getter for the size of the payload in bytes</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>size (number of bytes)</p>\n</blockquote>\n", "annotation": ": int"}, {"fullname": "aol.append_only_log_entry.AppendOnlyLogEntry.payload", "modulename": "aol.append_only_log_entry", "qualname": "AppendOnlyLogEntry.payload", "type": "variable", "doc": "<p>Getter for the payload</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>payload as bytes</p>\n</blockquote>\n", "annotation": ": bytes"}, {"fullname": "aol.append_only_log_entry.AppendOnlyLogEntry.json", "modulename": "aol.append_only_log_entry", "qualname": "AppendOnlyLogEntry.json", "type": "variable", "doc": "<p>Getter for returning the entry as plain json without using the @serializer</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>json string</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "config", "modulename": "config", "type": "module", "doc": "<h1 id=\"module-config\">Module *config\"</h1>\n\n<p>Implements the configuraion parameters</p>\n\n<ul>\n<li><strong>config.py:</strong> Configuration parameters for the peer nodes</li>\n<li>**config_gui.py: Configuration parameters for the GUI client</li>\n</ul>\n"}, {"fullname": "config.config", "modulename": "config.config", "type": "module", "doc": "<p>Configuration stuff</p>\n"}, {"fullname": "config.config.Config", "modulename": "config.config", "qualname": "Config", "type": "class", "doc": "<p>Configuartion variables</p>\n"}, {"fullname": "config.config.Config.__init__", "modulename": "config.config", "qualname": "Config.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "config.config.Config.CONNECTION_TIMEOUT", "modulename": "config.config", "qualname": "Config.CONNECTION_TIMEOUT", "type": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": " = 0.5"}, {"fullname": "config.config.Config.CONNECTION_KEEP_ALIVE", "modulename": "config.config", "qualname": "Config.CONNECTION_KEEP_ALIVE", "type": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": " = 60.0"}, {"fullname": "config.config.Config.LOGGING_LEVEL", "modulename": "config.config", "qualname": "Config.LOGGING_LEVEL", "type": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": " = 10"}, {"fullname": "config.config.Config.CHECK_FOLLOWING_INTERVAL", "modulename": "config.config", "qualname": "Config.CHECK_FOLLOWING_INTERVAL", "type": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": " = 3.0"}, {"fullname": "config.config.Config.config_logger", "modulename": "config.config", "qualname": "Config.config_logger", "type": "function", "doc": "<p>Standard configuration for logger on OS X</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>logger</strong>:  The logger</li>\n<li><strong>level</strong>:  The log level</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(logger: logging.Logger, level: int) -> None", "funcdef": "def"}, {"fullname": "config.gui_config", "modulename": "config.gui_config", "type": "module", "doc": "<p>Configuration variables for the GUI</p>\n"}, {"fullname": "config.gui_config.GuiConfig", "modulename": "config.gui_config", "qualname": "GuiConfig", "type": "class", "doc": "<p>Configuration variables</p>\n"}, {"fullname": "config.gui_config.GuiConfig.__init__", "modulename": "config.gui_config", "qualname": "GuiConfig.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "config.gui_config.GuiConfig.LOGGING_LEVEL", "modulename": "config.gui_config", "qualname": "GuiConfig.LOGGING_LEVEL", "type": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": " = 10"}, {"fullname": "config.gui_config.GuiConfig.config_logger", "modulename": "config.gui_config", "qualname": "GuiConfig.config_logger", "type": "function", "doc": "<p>Standard configuration for logger on OS X</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>logger</strong>:  The logger</li>\n<li><strong>level</strong>:  The log level</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(logger: logging.Logger, level: int) -> None", "funcdef": "def"}, {"fullname": "errors", "modulename": "errors", "type": "module", "doc": "<h1 id=\"module-errors\">Module \"errors\"</h1>\n\n<p>Implements the error class that is thrown if a peer node encounters errors</p>\n\n<ul>\n<li><strong>error.py:</strong> Error class</li>\n</ul>\n"}, {"fullname": "errors.errors", "modulename": "errors.errors", "type": "module", "doc": "<p>Special error class</p>\n"}, {"fullname": "errors.errors.AOLError", "modulename": "errors.errors", "qualname": "AOLError", "type": "class", "doc": "<p>Generic error for AOL exceptions</p>\n", "bases": "builtins.Exception"}, {"fullname": "errors.errors.AOLError.__init__", "modulename": "errors.errors", "qualname": "AOLError.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, msg: str, *args, **kwargs)", "funcdef": "def"}, {"fullname": "g2p_communication", "modulename": "g2p_communication", "type": "module", "doc": "<h1 id=\"module-g2p_communication\">Module \"g2p_communication\"</h1>\n\n<p>Implements the classes that are used for communicating from the GUI client to its peer node</p>\n\n<ul>\n<li><strong>g2p_communication_interface.py:</strong>\nAbstract class that defines the basic interface for the communication classes</li>\n<li><strong>g2p_create_log_data.py:</strong>\nClass that implements the \"create log\" command that the GUI may send to the peer</li>\n<li><strong>g2p_create_log_entry.py:</strong>\nClass that implements the \"create entry\" command</li>\n<li><strong>g2p_get_log_entry.py:</strong>\nClass that is used to send a \"get log entry\" command to the peer. If the peer receives such a\ncommand, it will send the request entry \"out of band\" back to the GUI client.</li>\n</ul>\n"}, {"fullname": "g2p_communication.g2p_communication_interface", "modulename": "g2p_communication.g2p_communication_interface", "type": "module", "doc": "<p>Interface for GUI to peer communications</p>\n"}, {"fullname": "g2p_communication.g2p_communication_interface.G2PCommunicationInterface", "modulename": "g2p_communication.g2p_communication_interface", "qualname": "G2PCommunicationInterface", "type": "class", "doc": "<p>Abstract class defining the interface for all GUI to peer communication. Shared between peer node and peer client\ncodes.</p>\n", "bases": "abc.ABC"}, {"fullname": "g2p_communication.g2p_create_log_data", "modulename": "g2p_communication.g2p_create_log_data", "type": "module", "doc": "<p>Command from GUI to peer to create a log</p>\n"}, {"fullname": "g2p_communication.g2p_create_log_data.G2PCreateLogData", "modulename": "g2p_communication.g2p_create_log_data", "qualname": "G2PCreateLogData", "type": "class", "doc": "<p>Class for create a log command sent from the GUI client to the peer node</p>\n", "bases": "g2p_communication.g2p_communication_interface.G2PCommunicationInterface"}, {"fullname": "g2p_communication.g2p_create_log_data.G2PCreateLogData.__init__", "modulename": "g2p_communication.g2p_create_log_data", "qualname": "G2PCreateLogData.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, title: str, description: str)", "funcdef": "def"}, {"fullname": "g2p_communication.g2p_create_log_data.G2PCreateLogData.title", "modulename": "g2p_communication.g2p_create_log_data", "qualname": "G2PCreateLogData.title", "type": "variable", "doc": "<p>Getter for log title</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>title</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "g2p_communication.g2p_create_log_data.G2PCreateLogData.description", "modulename": "g2p_communication.g2p_create_log_data", "qualname": "G2PCreateLogData.description", "type": "variable", "doc": "<p>Getter for log description</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>description</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "g2p_communication.g2p_create_log_entry", "modulename": "g2p_communication.g2p_create_log_entry", "type": "module", "doc": "<p>Implementation of command from GUI to peer to add an entry to a log</p>\n"}, {"fullname": "g2p_communication.g2p_create_log_entry.CreateLogEntryData", "modulename": "g2p_communication.g2p_create_log_entry", "qualname": "CreateLogEntryData", "type": "class", "doc": "<p>Implements the create an entry command send from the GUI client to the peer node</p>\n"}, {"fullname": "g2p_communication.g2p_create_log_entry.CreateLogEntryData.__init__", "modulename": "g2p_communication.g2p_create_log_entry", "qualname": "CreateLogEntryData.__init__", "type": "function", "doc": "<p>Constructor</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>mimetype</strong>:  Mimetype of the log entry</li>\n<li><strong>log_to_change</strong>:  log id of the log where the entry should be added</li>\n<li><strong>data</strong>:  payload of the entry</li>\n</ul>\n", "signature": "(self, mimetype: str, log_to_change: str, data: bytes)", "funcdef": "def"}, {"fullname": "g2p_communication.g2p_create_log_entry.CreateLogEntryData.mimetype", "modulename": "g2p_communication.g2p_create_log_entry", "qualname": "CreateLogEntryData.mimetype", "type": "variable", "doc": "<p>Getter for the mimetype</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>mimetype</p>\n</blockquote>\n"}, {"fullname": "g2p_communication.g2p_create_log_entry.CreateLogEntryData.log_to_change", "modulename": "g2p_communication.g2p_create_log_entry", "qualname": "CreateLogEntryData.log_to_change", "type": "variable", "doc": "<p>Getter for the log id</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>log id</p>\n</blockquote>\n"}, {"fullname": "g2p_communication.g2p_create_log_entry.CreateLogEntryData.data", "modulename": "g2p_communication.g2p_create_log_entry", "qualname": "CreateLogEntryData.data", "type": "variable", "doc": "<p>Getter for the entry data (payload)</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>data (payload)</p>\n</blockquote>\n"}, {"fullname": "g2p_communication.g2p_get_log_entry", "modulename": "g2p_communication.g2p_get_log_entry", "type": "module", "doc": "<p>Implementation of command to get an entry from the peer (GUI to peer command)</p>\n"}, {"fullname": "g2p_communication.g2p_get_log_entry.GetLogEntry", "modulename": "g2p_communication.g2p_get_log_entry", "qualname": "GetLogEntry", "type": "class", "doc": "<p>Class implements the command sent from the GUI client to the peer for requesting an entry</p>\n", "bases": "g2p_communication.g2p_communication_interface.G2PCommunicationInterface"}, {"fullname": "g2p_communication.g2p_get_log_entry.GetLogEntry.__init__", "modulename": "g2p_communication.g2p_get_log_entry", "qualname": "GetLogEntry.__init__", "type": "function", "doc": "<p>Constructor</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>log_id</strong>:  Id of the log</li>\n<li><strong>entry_num</strong>:  Index number of the entry</li>\n</ul>\n", "signature": "(self, log_id: str, entry_num: int)", "funcdef": "def"}, {"fullname": "g2p_communication.g2p_get_log_entry.GetLogEntry.log_id", "modulename": "g2p_communication.g2p_get_log_entry", "qualname": "GetLogEntry.log_id", "type": "variable", "doc": "<p>Getter for the log ID</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>log ID</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "g2p_communication.g2p_get_log_entry.GetLogEntry.entry_num", "modulename": "g2p_communication.g2p_get_log_entry", "qualname": "GetLogEntry.entry_num", "type": "variable", "doc": "<p>Getter for the entry index</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>index</p>\n</blockquote>\n", "annotation": ": int"}, {"fullname": "gui_client", "modulename": "gui_client", "type": "module", "doc": "<p></p>\n"}, {"fullname": "gui_client.audio_pipe", "modulename": "gui_client.audio_pipe", "type": "module", "doc": "<p></p>\n"}, {"fullname": "gui_client.audio_pipe.AudioPipe", "modulename": "gui_client.audio_pipe", "qualname": "AudioPipe", "type": "class", "doc": "<p>This class implements an internal pipe which is used for communication between the python thread and the audio\ninterface thread. As it is well known, python does not really support true multithreading due to the internal use\nof global state variables (but implements the concept of coroutines based on asyncio). Tkinter which is used as GUI\nframework is based on the quite old Tcl/Tk. Thus, in the python interpreter, there is an embedded Tcl/Tk-interpreter\nwhich handles the GUI stuff. Tcl/Tk implements its own eventloop and event handling which is not compatible with\nthe asyncio way of doing things. The audio interface itself is using \"real\" threads since it's implemented using\nC/C++.</p>\n"}, {"fullname": "gui_client.audio_pipe.AudioPipe.__init__", "modulename": "gui_client.audio_pipe", "qualname": "AudioPipe.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gui_client.audio_pipe.AudioPipe.new_pipe", "modulename": "gui_client.audio_pipe", "qualname": "AudioPipe.new_pipe", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "gui_client.audio_pipe.AudioPipe.close_consumer", "modulename": "gui_client.audio_pipe", "qualname": "AudioPipe.close_consumer", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "gui_client.audio_pipe.AudioPipe.close_producer", "modulename": "gui_client.audio_pipe", "qualname": "AudioPipe.close_producer", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "gui_client.audio_pipe.AudioPipe.write", "modulename": "gui_client.audio_pipe", "qualname": "AudioPipe.write", "type": "function", "doc": "<p></p>\n", "signature": "(self, buf: bytes) -> int", "funcdef": "def"}, {"fullname": "gui_client.audio_pipe.AudioPipe.read", "modulename": "gui_client.audio_pipe", "qualname": "AudioPipe.read", "type": "function", "doc": "<p></p>\n", "signature": "(self, n: int) -> bytes", "funcdef": "def"}, {"fullname": "gui_client.audio_pipe.AudioPipe.consumer_is_open", "modulename": "gui_client.audio_pipe", "qualname": "AudioPipe.consumer_is_open", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "gui_client.audio_pipe.AudioPipe.producer_is_open", "modulename": "gui_client.audio_pipe", "qualname": "AudioPipe.producer_is_open", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "gui_client.audioplay_dialog", "modulename": "gui_client.audioplay_dialog", "type": "module", "doc": "<p></p>\n"}, {"fullname": "gui_client.audioplay_dialog.AudioPlayDialog", "modulename": "gui_client.audioplay_dialog", "qualname": "AudioPlayDialog", "type": "class", "doc": "<p>Class to open dialogs.</p>\n\n<p>This class is intended as a base class for custom dialogs</p>\n", "bases": "tkinter.simpledialog.Dialog"}, {"fullname": "gui_client.audioplay_dialog.AudioPlayDialog.__init__", "modulename": "gui_client.audioplay_dialog", "qualname": "AudioPlayDialog.__init__", "type": "function", "doc": "<p>Initialize a dialog.</p>\n\n<p>Arguments:</p>\n\n<pre><code>parent -- a parent window (the application window)\n\ntitle -- the dialog title\n</code></pre>\n", "signature": "(\n    self,\n    parent,\n    title,\n    gui_api: gui_client.g2p_commands.G2PCommands,\n    log_id: str,\n    audio_pipe: gui_client.audio_pipe.AudioPipe\n)", "funcdef": "def"}, {"fullname": "gui_client.audioplay_dialog.AudioPlayDialog.body", "modulename": "gui_client.audioplay_dialog", "qualname": "AudioPlayDialog.body", "type": "function", "doc": "<p>create dialog body.</p>\n\n<p>return widget that should have initial focus.\nThis method should be overridden, and is called\nby the __init__ method.</p>\n", "signature": "(self, frame)", "funcdef": "def"}, {"fullname": "gui_client.audioplay_dialog.AudioPlayDialog.start_play", "modulename": "gui_client.audioplay_dialog", "qualname": "AudioPlayDialog.start_play", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "gui_client.audioplay_dialog.AudioPlayDialog.stop_play", "modulename": "gui_client.audioplay_dialog", "qualname": "AudioPlayDialog.stop_play", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "gui_client.audioplay_dialog.AudioPlayDialog.play_callback", "modulename": "gui_client.audioplay_dialog", "qualname": "AudioPlayDialog.play_callback", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    outdata: _cffi_backend.buffer,\n    frames: int,\n    time: Any,\n    status: sounddevice.CallbackFlags\n) -> None", "funcdef": "def"}, {"fullname": "gui_client.audioplay_dialog.AudioPlayDialog.play_finished_callback", "modulename": "gui_client.audioplay_dialog", "qualname": "AudioPlayDialog.play_finished_callback", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "gui_client.audioplay_dialog.AudioPlayDialog.buttonbox", "modulename": "gui_client.audioplay_dialog", "qualname": "AudioPlayDialog.buttonbox", "type": "function", "doc": "<p>add standard button box.</p>\n\n<p>override if you do not want the standard buttons</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gui_client.audioplay_dialog.AudioPlayDialog.cancel_pressed", "modulename": "gui_client.audioplay_dialog", "qualname": "AudioPlayDialog.cancel_pressed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gui_client.audioplay_dialog.AudioPlayDialog.success", "modulename": "gui_client.audioplay_dialog", "qualname": "AudioPlayDialog.success", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool"}, {"fullname": "gui_client.connect_dialog", "modulename": "gui_client.connect_dialog", "type": "module", "doc": "<p></p>\n"}, {"fullname": "gui_client.connect_dialog.ConnectDialog", "modulename": "gui_client.connect_dialog", "qualname": "ConnectDialog", "type": "class", "doc": "<p>This class is used for the \"advanced\" GUI to create a connection dialog (entry of host and port)</p>\n", "bases": "tkinter.simpledialog.Dialog"}, {"fullname": "gui_client.connect_dialog.ConnectDialog.__init__", "modulename": "gui_client.connect_dialog", "qualname": "ConnectDialog.__init__", "type": "function", "doc": "<p>Initialize a dialog.</p>\n\n<p>Arguments:</p>\n\n<pre><code>parent -- a parent window (the application window)\n\ntitle -- the dialog title\n</code></pre>\n", "signature": "(self, parent: tkinter.ttk.Frame, title: str)", "funcdef": "def"}, {"fullname": "gui_client.connect_dialog.ConnectDialog.body", "modulename": "gui_client.connect_dialog", "qualname": "ConnectDialog.body", "type": "function", "doc": "<p>create dialog body.</p>\n\n<p>return widget that should have initial focus.\nThis method should be overridden, and is called\nby the __init__ method.</p>\n", "signature": "(self, frame)", "funcdef": "def"}, {"fullname": "gui_client.connect_dialog.ConnectDialog.buttonbox", "modulename": "gui_client.connect_dialog", "qualname": "ConnectDialog.buttonbox", "type": "function", "doc": "<p>add standard button box.</p>\n\n<p>override if you do not want the standard buttons</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gui_client.connect_dialog.ConnectDialog.ok_pressed", "modulename": "gui_client.connect_dialog", "qualname": "ConnectDialog.ok_pressed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gui_client.connect_dialog.ConnectDialog.cancel_pressed", "modulename": "gui_client.connect_dialog", "qualname": "ConnectDialog.cancel_pressed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gui_client.create_audio_stream", "modulename": "gui_client.create_audio_stream", "type": "module", "doc": "<p></p>\n"}, {"fullname": "gui_client.create_audio_stream.CreateAudioStreamDialog", "modulename": "gui_client.create_audio_stream", "qualname": "CreateAudioStreamDialog", "type": "class", "doc": "<p>Class to open dialogs.</p>\n\n<p>This class is intended as a base class for custom dialogs</p>\n", "bases": "tkinter.simpledialog.Dialog"}, {"fullname": "gui_client.create_audio_stream.CreateAudioStreamDialog.__init__", "modulename": "gui_client.create_audio_stream", "qualname": "CreateAudioStreamDialog.__init__", "type": "function", "doc": "<p>Initialize a dialog.</p>\n\n<p>Arguments:</p>\n\n<pre><code>parent -- a parent window (the application window)\n\ntitle -- the dialog title\n</code></pre>\n", "signature": "(\n    self,\n    parent,\n    title,\n    gui_api: gui_client.g2p_commands.G2PCommands,\n    stream_log_id: tkinter.StringVar\n)", "funcdef": "def"}, {"fullname": "gui_client.create_audio_stream.CreateAudioStreamDialog.body", "modulename": "gui_client.create_audio_stream", "qualname": "CreateAudioStreamDialog.body", "type": "function", "doc": "<p>create dialog body.</p>\n\n<p>return widget that should have initial focus.\nThis method should be overridden, and is called\nby the __init__ method.</p>\n", "signature": "(self, frame)", "funcdef": "def"}, {"fullname": "gui_client.create_audio_stream.CreateAudioStreamDialog.start_stream", "modulename": "gui_client.create_audio_stream", "qualname": "CreateAudioStreamDialog.start_stream", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gui_client.create_audio_stream.CreateAudioStreamDialog.stop_stream", "modulename": "gui_client.create_audio_stream", "qualname": "CreateAudioStreamDialog.stop_stream", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "gui_client.create_audio_stream.CreateAudioStreamDialog.stream_callback", "modulename": "gui_client.create_audio_stream", "qualname": "CreateAudioStreamDialog.stream_callback", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    indata: _cffi_backend.buffer,\n    frames: int,\n    time: Any,\n    status: sounddevice.CallbackFlags\n) -> None", "funcdef": "def"}, {"fullname": "gui_client.create_audio_stream.CreateAudioStreamDialog.stream_finished_callback", "modulename": "gui_client.create_audio_stream", "qualname": "CreateAudioStreamDialog.stream_finished_callback", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "gui_client.create_audio_stream.CreateAudioStreamDialog.buttonbox", "modulename": "gui_client.create_audio_stream", "qualname": "CreateAudioStreamDialog.buttonbox", "type": "function", "doc": "<p>add standard button box.</p>\n\n<p>override if you do not want the standard buttons</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gui_client.create_audio_stream.CreateAudioStreamDialog.cancel_pressed", "modulename": "gui_client.create_audio_stream", "qualname": "CreateAudioStreamDialog.cancel_pressed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gui_client.create_audio_stream.CreateAudioStreamDialog.success", "modulename": "gui_client.create_audio_stream", "qualname": "CreateAudioStreamDialog.success", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool"}, {"fullname": "gui_client.create_audioentry_dialog", "modulename": "gui_client.create_audioentry_dialog", "type": "module", "doc": "<p></p>\n"}, {"fullname": "gui_client.create_audioentry_dialog.CreateAudioEntryDialog", "modulename": "gui_client.create_audioentry_dialog", "qualname": "CreateAudioEntryDialog", "type": "class", "doc": "<p>Class to open dialogs.</p>\n\n<p>This class is intended as a base class for custom dialogs</p>\n", "bases": "tkinter.simpledialog.Dialog"}, {"fullname": "gui_client.create_audioentry_dialog.CreateAudioEntryDialog.__init__", "modulename": "gui_client.create_audioentry_dialog", "qualname": "CreateAudioEntryDialog.__init__", "type": "function", "doc": "<p>Initialize a dialog.</p>\n\n<p>Arguments:</p>\n\n<pre><code>parent -- a parent window (the application window)\n\ntitle -- the dialog title\n</code></pre>\n", "signature": "(\n    self,\n    parent,\n    title,\n    gui_api: gui_client.g2p_commands.G2PCommands,\n    log_id: str\n)", "funcdef": "def"}, {"fullname": "gui_client.create_audioentry_dialog.CreateAudioEntryDialog.body", "modulename": "gui_client.create_audioentry_dialog", "qualname": "CreateAudioEntryDialog.body", "type": "function", "doc": "<p>create dialog body.</p>\n\n<p>return widget that should have initial focus.\nThis method should be overridden, and is called\nby the __init__ method.</p>\n", "signature": "(self, frame)", "funcdef": "def"}, {"fullname": "gui_client.create_audioentry_dialog.CreateAudioEntryDialog.start_rec", "modulename": "gui_client.create_audioentry_dialog", "qualname": "CreateAudioEntryDialog.start_rec", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "gui_client.create_audioentry_dialog.CreateAudioEntryDialog.stop_rec", "modulename": "gui_client.create_audioentry_dialog", "qualname": "CreateAudioEntryDialog.stop_rec", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "gui_client.create_audioentry_dialog.CreateAudioEntryDialog.rec_callback", "modulename": "gui_client.create_audioentry_dialog", "qualname": "CreateAudioEntryDialog.rec_callback", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    indata: _cffi_backend.buffer,\n    frames: int,\n    time: Any,\n    status: sounddevice.CallbackFlags\n) -> None", "funcdef": "def"}, {"fullname": "gui_client.create_audioentry_dialog.CreateAudioEntryDialog.rec_finished_callback", "modulename": "gui_client.create_audioentry_dialog", "qualname": "CreateAudioEntryDialog.rec_finished_callback", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "gui_client.create_audioentry_dialog.CreateAudioEntryDialog.buttonbox", "modulename": "gui_client.create_audioentry_dialog", "qualname": "CreateAudioEntryDialog.buttonbox", "type": "function", "doc": "<p>add standard button box.</p>\n\n<p>override if you do not want the standard buttons</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gui_client.create_audioentry_dialog.CreateAudioEntryDialog.cancel_pressed", "modulename": "gui_client.create_audioentry_dialog", "qualname": "CreateAudioEntryDialog.cancel_pressed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gui_client.create_audioentry_dialog.CreateAudioEntryDialog.success", "modulename": "gui_client.create_audioentry_dialog", "qualname": "CreateAudioEntryDialog.success", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool"}, {"fullname": "gui_client.create_log_dialog", "modulename": "gui_client.create_log_dialog", "type": "module", "doc": "<p></p>\n"}, {"fullname": "gui_client.create_log_dialog.CreateLogDialog", "modulename": "gui_client.create_log_dialog", "qualname": "CreateLogDialog", "type": "class", "doc": "<p>This class is used for the log creation dialog (entry of host and port)</p>\n", "bases": "tkinter.simpledialog.Dialog"}, {"fullname": "gui_client.create_log_dialog.CreateLogDialog.__init__", "modulename": "gui_client.create_log_dialog", "qualname": "CreateLogDialog.__init__", "type": "function", "doc": "<p>Initialize a dialog.</p>\n\n<p>Arguments:</p>\n\n<pre><code>parent -- a parent window (the application window)\n\ntitle -- the dialog title\n</code></pre>\n", "signature": "(self, parent, title)", "funcdef": "def"}, {"fullname": "gui_client.create_log_dialog.CreateLogDialog.body", "modulename": "gui_client.create_log_dialog", "qualname": "CreateLogDialog.body", "type": "function", "doc": "<p>create dialog body.</p>\n\n<p>return widget that should have initial focus.\nThis method should be overridden, and is called\nby the __init__ method.</p>\n", "signature": "(self, frame)", "funcdef": "def"}, {"fullname": "gui_client.create_log_dialog.CreateLogDialog.buttonbox", "modulename": "gui_client.create_log_dialog", "qualname": "CreateLogDialog.buttonbox", "type": "function", "doc": "<p>add standard button box.</p>\n\n<p>override if you do not want the standard buttons</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gui_client.create_log_dialog.CreateLogDialog.ok_pressed", "modulename": "gui_client.create_log_dialog", "qualname": "CreateLogDialog.ok_pressed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gui_client.create_log_dialog.CreateLogDialog.cancel_pressed", "modulename": "gui_client.create_log_dialog", "qualname": "CreateLogDialog.cancel_pressed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gui_client.create_log_dialog.CreateLogDialog.success", "modulename": "gui_client.create_log_dialog", "qualname": "CreateLogDialog.success", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool"}, {"fullname": "gui_client.create_log_dialog.CreateLogDialog.log_title", "modulename": "gui_client.create_log_dialog", "qualname": "CreateLogDialog.log_title", "type": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "gui_client.create_log_dialog.CreateLogDialog.log_description", "modulename": "gui_client.create_log_dialog", "qualname": "CreateLogDialog.log_description", "type": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "gui_client.create_logentry_dialog", "modulename": "gui_client.create_logentry_dialog", "type": "module", "doc": "<p></p>\n"}, {"fullname": "gui_client.create_logentry_dialog.CreateLogEntryDialog", "modulename": "gui_client.create_logentry_dialog", "qualname": "CreateLogEntryDialog", "type": "class", "doc": "<p>This class is used for the log creation dialog (entry of host and port)</p>\n", "bases": "tkinter.simpledialog.Dialog"}, {"fullname": "gui_client.create_logentry_dialog.CreateLogEntryDialog.__init__", "modulename": "gui_client.create_logentry_dialog", "qualname": "CreateLogEntryDialog.__init__", "type": "function", "doc": "<p>Initialize a dialog.</p>\n\n<p>Arguments:</p>\n\n<pre><code>parent -- a parent window (the application window)\n\ntitle -- the dialog title\n</code></pre>\n", "signature": "(self, parent, title)", "funcdef": "def"}, {"fullname": "gui_client.create_logentry_dialog.CreateLogEntryDialog.body", "modulename": "gui_client.create_logentry_dialog", "qualname": "CreateLogEntryDialog.body", "type": "function", "doc": "<p>create dialog body.</p>\n\n<p>return widget that should have initial focus.\nThis method should be overridden, and is called\nby the __init__ method.</p>\n", "signature": "(self, frame)", "funcdef": "def"}, {"fullname": "gui_client.create_logentry_dialog.CreateLogEntryDialog.buttonbox", "modulename": "gui_client.create_logentry_dialog", "qualname": "CreateLogEntryDialog.buttonbox", "type": "function", "doc": "<p>add standard button box.</p>\n\n<p>override if you do not want the standard buttons</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gui_client.create_logentry_dialog.CreateLogEntryDialog.ok_pressed", "modulename": "gui_client.create_logentry_dialog", "qualname": "CreateLogEntryDialog.ok_pressed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gui_client.create_logentry_dialog.CreateLogEntryDialog.cancel_pressed", "modulename": "gui_client.create_logentry_dialog", "qualname": "CreateLogEntryDialog.cancel_pressed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gui_client.create_logentry_dialog.CreateLogEntryDialog.success", "modulename": "gui_client.create_logentry_dialog", "qualname": "CreateLogEntryDialog.success", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool"}, {"fullname": "gui_client.create_logentry_dialog.CreateLogEntryDialog.entry_text", "modulename": "gui_client.create_logentry_dialog", "qualname": "CreateLogEntryDialog.entry_text", "type": "variable", "doc": "<p></p>\n", "annotation": ": str"}, {"fullname": "gui_client.echo_audio_stream", "modulename": "gui_client.echo_audio_stream", "type": "module", "doc": "<p></p>\n"}, {"fullname": "gui_client.echo_audio_stream.EchoAudioStream", "modulename": "gui_client.echo_audio_stream", "qualname": "EchoAudioStream", "type": "class", "doc": "<p></p>\n"}, {"fullname": "gui_client.echo_audio_stream.EchoAudioStream.__init__", "modulename": "gui_client.echo_audio_stream", "qualname": "EchoAudioStream.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    frame: tkinter.ttk.Frame,\n    echo_peer: str,\n    gui_api: gui_client.g2p_commands.G2PCommands,\n    stream_log_id: tkinter.StringVar\n)", "funcdef": "def"}, {"fullname": "gui_client.echo_audio_stream.EchoAudioStream.start", "modulename": "gui_client.echo_audio_stream", "qualname": "EchoAudioStream.start", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gui_client.echo_audio_stream.EchoAudioStream.stop", "modulename": "gui_client.echo_audio_stream", "qualname": "EchoAudioStream.stop", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gui_client.echo_audio_stream.EchoAudioStream.echo_callback", "modulename": "gui_client.echo_audio_stream", "qualname": "EchoAudioStream.echo_callback", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    indata: _cffi_backend.buffer,\n    frames: int,\n    time: Any,\n    status: sounddevice.CallbackFlags\n) -> None", "funcdef": "def"}, {"fullname": "gui_client.echo_audio_stream.EchoAudioStream.echo_finished_callback", "modulename": "gui_client.echo_audio_stream", "qualname": "EchoAudioStream.echo_finished_callback", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "gui_client.echo_audio_stream.EchoAudioStream.success", "modulename": "gui_client.echo_audio_stream", "qualname": "EchoAudioStream.success", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool"}, {"fullname": "gui_client.g2p_commands", "modulename": "gui_client.g2p_commands", "type": "module", "doc": "<p></p>\n"}, {"fullname": "gui_client.g2p_commands.G2PCommands", "modulename": "gui_client.g2p_commands", "qualname": "G2PCommands", "type": "class", "doc": "<p>This class creates a user interface for the user. It connects to a peer node and allows a user to control it\nby sending specific p2p_commands. All p2p_commands that are sent using the gui, are transmitted via TCP to the peer node\nand there executed by the node itself.</p>\n"}, {"fullname": "gui_client.g2p_commands.G2PCommands.__init__", "modulename": "gui_client.g2p_commands", "qualname": "G2PCommands.__init__", "type": "function", "doc": "<p>The socket and the filedescriber get initialized to None here.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gui_client.g2p_commands.G2PCommands.g2p_connect", "modulename": "gui_client.g2p_commands", "qualname": "G2PCommands.g2p_connect", "type": "function", "doc": "<p>This function connects the GUI via TCP connection to the peer node.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>host</strong>:  The hostname/IP of the peer node</li>\n<li><strong>port</strong>:  The port of the peer node</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    self,\n    host: str,\n    port: int\n) -> Optional[Tuple[socket.socket, p2g_communication.p2g_connect_response.P2GConnectResponse]]", "funcdef": "def"}, {"fullname": "gui_client.g2p_commands.G2PCommands.g2p_disconnect", "modulename": "gui_client.g2p_commands", "qualname": "G2PCommands.g2p_disconnect", "type": "function", "doc": "<p>This function severs the connection between GUI and peer-node</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "gui_client.g2p_commands.G2PCommands.g2p_send_ping_command", "modulename": "gui_client.g2p_commands", "qualname": "G2PCommands.g2p_send_ping_command", "type": "function", "doc": "<p>This function sends a ping command from the user/GUI via TCP connection to the peer-node</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "gui_client.g2p_commands.G2PCommands.g2p_send_create_log_command", "modulename": "gui_client.g2p_commands", "qualname": "G2PCommands.g2p_send_create_log_command", "type": "function", "doc": "<p></p>\n", "signature": "(self, data: bytes) -> None", "funcdef": "def"}, {"fullname": "gui_client.g2p_commands.G2PCommands.g2p_send_create_log_entry_command", "modulename": "gui_client.g2p_commands", "qualname": "G2PCommands.g2p_send_create_log_entry_command", "type": "function", "doc": "<p></p>\n", "signature": "(self, mimetype: str, log_to_change: str, data: bytes) -> None", "funcdef": "def"}, {"fullname": "gui_client.g2p_commands.G2PCommands.g2p_send_get_log_entry_command", "modulename": "gui_client.g2p_commands", "qualname": "G2PCommands.g2p_send_get_log_entry_command", "type": "function", "doc": "<p></p>\n", "signature": "(self, log_id: str, entry_num: int) -> None", "funcdef": "def"}, {"fullname": "gui_client.g2p_commands.G2PCommands.g2p_send_get_followers_command", "modulename": "gui_client.g2p_commands", "qualname": "G2PCommands.g2p_send_get_followers_command", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "gui_client.globals", "modulename": "gui_client.globals", "type": "module", "doc": "<p></p>\n"}, {"fullname": "gui_client.globals.global_output_stream", "modulename": "gui_client.globals", "qualname": "global_output_stream", "type": "variable", "doc": "<p></p>\n", "annotation": ": sounddevice.RawOutputStream | None", "default_value": " = None"}, {"fullname": "gui_client.gui_command_protocol", "modulename": "gui_client.gui_command_protocol", "type": "module", "doc": "<p></p>\n"}, {"fullname": "gui_client.gui_command_protocol.GuiCommands", "modulename": "gui_client.gui_command_protocol", "qualname": "GuiCommands", "type": "class", "doc": "<p>This enum contains all the p2p_commands that can be sent from the GUI to the peer-node.</p>\n", "bases": "enum.Enum"}, {"fullname": "gui_client.gui_command_protocol.GuiCommands.GUI_PING", "modulename": "gui_client.gui_command_protocol", "qualname": "GuiCommands.GUI_PING", "type": "variable", "doc": "<p></p>\n", "default_value": " = <GuiCommands.GUI_PING: 'GUI_PING'>"}, {"fullname": "gui_client.gui_command_protocol.GuiCommands.BROADCAST", "modulename": "gui_client.gui_command_protocol", "qualname": "GuiCommands.BROADCAST", "type": "variable", "doc": "<p></p>\n", "default_value": " = <GuiCommands.BROADCAST: 'BROADCAST'>"}, {"fullname": "gui_client.gui_command_protocol.GuiCommands.GUI_CREATE_LOG", "modulename": "gui_client.gui_command_protocol", "qualname": "GuiCommands.GUI_CREATE_LOG", "type": "variable", "doc": "<p></p>\n", "default_value": " = <GuiCommands.GUI_CREATE_LOG: 'GUI_CREATE_LOG'>"}, {"fullname": "gui_client.gui_command_protocol.GuiCommands.GUI_CREATE_LOG_ENTRY", "modulename": "gui_client.gui_command_protocol", "qualname": "GuiCommands.GUI_CREATE_LOG_ENTRY", "type": "variable", "doc": "<p></p>\n", "default_value": " = <GuiCommands.GUI_CREATE_LOG_ENTRY: 'GUI_CREATE_LOG_ENTRY'>"}, {"fullname": "gui_client.gui_command_protocol.GuiCommands.GUI_GET_LOG_ENTRY", "modulename": "gui_client.gui_command_protocol", "qualname": "GuiCommands.GUI_GET_LOG_ENTRY", "type": "variable", "doc": "<p></p>\n", "default_value": " = <GuiCommands.GUI_GET_LOG_ENTRY: 'GUI_GET_LOG_ENTRY'>"}, {"fullname": "gui_client.gui_command_protocol.GuiCommands.GUI_GET_FOLLOWERS", "modulename": "gui_client.gui_command_protocol", "qualname": "GuiCommands.GUI_GET_FOLLOWERS", "type": "variable", "doc": "<p></p>\n", "default_value": " = <GuiCommands.GUI_GET_FOLLOWERS: 'GUI_GET_FOLLOWERS'>"}, {"fullname": "gui_client.gui_command_protocol.GuiConnectionClosed", "modulename": "gui_client.gui_command_protocol", "qualname": "GuiConnectionClosed", "type": "class", "doc": "<p>A custom error, that handles GuiConnectionClosed errors</p>\n", "bases": "builtins.Exception"}, {"fullname": "gui_client.gui_command_protocol.GuiProtocolError", "modulename": "gui_client.gui_command_protocol", "qualname": "GuiProtocolError", "type": "class", "doc": "<p>A custom error used to handle AOLProtocolError errors.</p>\n", "bases": "builtins.Exception"}, {"fullname": "gui_client.gui_command_protocol.GuiProtocolError.__init__", "modulename": "gui_client.gui_command_protocol", "qualname": "GuiProtocolError.__init__", "type": "function", "doc": "<p>Initializes the GuiProtocolError.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>message</strong>:  The message that is to be printed if this error occurs.</li>\n</ul>\n", "signature": "(self, message: str)", "funcdef": "def"}, {"fullname": "gui_client.gui_command_protocol.GuiPeerError", "modulename": "gui_client.gui_command_protocol", "qualname": "GuiPeerError", "type": "class", "doc": "<p>Common base class for all non-exit exceptions.</p>\n", "bases": "builtins.Exception"}, {"fullname": "gui_client.gui_command_protocol.GuiPeerError.__init__", "modulename": "gui_client.gui_command_protocol", "qualname": "GuiPeerError.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, message: str)", "funcdef": "def"}, {"fullname": "gui_client.gui_command_protocol.g2p_send_command", "modulename": "gui_client.gui_command_protocol", "qualname": "g2p_send_command", "type": "function", "doc": "<p>This function sends a command from the GUI to the peer-node.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>command</strong>:  The command, that is to be transmitted.</li>\n<li><strong>socket</strong>:  The socket of the TCP connection between GUI and peer-node</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    command: gui_client.gui_command_protocol.GuiCommands,\n    socket: socket.socket\n) -> None", "funcdef": "def"}, {"fullname": "gui_client.gui_command_protocol.g2p_send_package", "modulename": "gui_client.gui_command_protocol", "qualname": "g2p_send_package", "type": "function", "doc": "<p></p>\n", "signature": "(socket: socket.socket, data: bytes) -> None", "funcdef": "def"}, {"fullname": "gui_client.gui_command_protocol.pfg_receive_package", "modulename": "gui_client.gui_command_protocol", "qualname": "pfg_receive_package", "type": "function", "doc": "<p></p>\n", "signature": "(reader: asyncio.streams.StreamReader) -> bytes | None", "funcdef": "async def"}, {"fullname": "gui_client.gui_command_protocol.p2g_send_package", "modulename": "gui_client.gui_command_protocol", "qualname": "p2g_send_package", "type": "function", "doc": "<p>This function sends a data package from the peer to the user/GUI.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data</strong>:  Data that is to be transmitted.</li>\n<li><strong>writer</strong>:  The writer of the socket in the TCP connection between peer-node and the GUI.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(data: bytes, writer: asyncio.streams.StreamWriter) -> None", "funcdef": "async def"}, {"fullname": "gui_client.gui_command_protocol.p2g_send_error", "modulename": "gui_client.gui_command_protocol", "qualname": "p2g_send_error", "type": "function", "doc": "<p>This method sends an error message. In order to indicate an error, the first length is set to 0xFFFFFFFF, followed\nby the actual length of the error message (as 4 bytes binary, big-endian, unsigned).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>error_object</strong>:  Error</li>\n<li><strong>writer</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    error_object: errors.errors.AOLError,\n    writer: asyncio.streams.StreamWriter\n) -> None", "funcdef": "async def"}, {"fullname": "gui_client.gui_command_protocol.gfp_receive_package", "modulename": "gui_client.gui_command_protocol", "qualname": "gfp_receive_package", "type": "function", "doc": "<p>Receive data from peer (in GUI)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>sock</strong>:  The \"socket\" of the TCP connection between GUI and peer-node</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>bytes, The data payload</p>\n</blockquote>\n", "signature": "(sock: socket.socket) -> str", "funcdef": "def"}, {"fullname": "gui_client.gui_command_protocol.gfp_receive_command_response", "modulename": "gui_client.gui_command_protocol", "qualname": "gfp_receive_command_response", "type": "function", "doc": "<p>This function handles the results of a command that was sent by the gui and was processed by it's peer-node.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>sock</strong>:  The \"socket\" of the corresponding TCP connection</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The result, that a command, that has been sent to the peer-node, has produced. Type: GuiResults</p>\n</blockquote>\n", "signature": "(\n    sock: socket.socket\n) -> p2g_communication.p2g_communication_interface.P2GCommunicationInterface", "funcdef": "def"}, {"fullname": "gui_client.gui_command_protocol.pfg_command_handler", "modulename": "gui_client.gui_command_protocol", "qualname": "pfg_command_handler", "type": "function", "doc": "<p>Function that handles a command that the peer gets from it's connected user/GUI</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>reader</strong>:  The reader of the socket in the TCP connection between peer-node and the GUI.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>GuiCommands</p>\n</blockquote>\n", "signature": "(\n    reader: asyncio.streams.StreamReader\n) -> gui_client.gui_command_protocol.GuiCommands", "funcdef": "async def"}, {"fullname": "p2g_communication", "modulename": "p2g_communication", "type": "module", "doc": "<p></p>\n"}, {"fullname": "p2g_communication.p2g_audio_stream_entry_response", "modulename": "p2g_communication.p2g_audio_stream_entry_response", "type": "module", "doc": "<p>Implements the response of the peer to the connected GUI if an AudioStream entry is received</p>\n"}, {"fullname": "p2g_communication.p2g_audio_stream_entry_response.P2GAudioStreamEntryResponse", "modulename": "p2g_communication.p2g_audio_stream_entry_response", "qualname": "P2GAudioStreamEntryResponse", "type": "class", "doc": "<p>A class holding an audio stream frame</p>\n", "bases": "p2g_communication.p2g_communication_interface.P2GCommunicationInterface"}, {"fullname": "p2g_communication.p2g_audio_stream_entry_response.P2GAudioStreamEntryResponse.__init__", "modulename": "p2g_communication.p2g_audio_stream_entry_response", "qualname": "P2GAudioStreamEntryResponse.__init__", "type": "function", "doc": "<p>Constructor</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>payload</strong>:  audio frame payload</li>\n</ul>\n", "signature": "(self, payload: bytes)", "funcdef": "def"}, {"fullname": "p2g_communication.p2g_audio_stream_entry_response.P2GAudioStreamEntryResponse.payload", "modulename": "p2g_communication.p2g_audio_stream_entry_response", "qualname": "P2GAudioStreamEntryResponse.payload", "type": "variable", "doc": "<p>Getter for audio stream payload</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>audio stream frame</p>\n</blockquote>\n", "annotation": ": bytes"}, {"fullname": "p2g_communication.p2g_communication_interface", "modulename": "p2g_communication.p2g_communication_interface", "type": "module", "doc": "<p>Interface for synchronous or out-of-band communication from the peer node to the GUI client. Most communication from\nthe peer to the GUI client is asynchronous. The GUI Client sends a command to the peer and free's the TCP connection.\nAs soon as the peer has the response ready, it sends a command response object to the GUI client.</p>\n\n<p>The GUI client handles all responses from the peer in an asynchronous callback established with tk.createfilehandler.\nThis is necessary in order not to block the event loop of the tkinter based GUI client!</p>\n"}, {"fullname": "p2g_communication.p2g_communication_interface.P2GCommunicationInterface", "modulename": "p2g_communication.p2g_communication_interface", "qualname": "P2GCommunicationInterface", "type": "class", "doc": "<p>Abstract class implementing the interface for commands from the peer node to the GUI client</p>\n", "bases": "abc.ABC"}, {"fullname": "p2g_communication.p2g_connect_response", "modulename": "p2g_communication.p2g_connect_response", "type": "module", "doc": "<p>Response to a connect command (this is being returned to the GUI by the peer on receiving a connect command\nfrom the GUI)</p>\n"}, {"fullname": "p2g_communication.p2g_connect_response.P2GConnectResponse", "modulename": "p2g_communication.p2g_connect_response", "qualname": "P2GConnectResponse", "type": "class", "doc": "<p>Class that implements the connect response (peer to GUI) after the peer executed a connect command received\nfrom the peer</p>\n", "bases": "p2g_communication.p2g_communication_interface.P2GCommunicationInterface"}, {"fullname": "p2g_communication.p2g_connect_response.P2GConnectResponse.__init__", "modulename": "p2g_communication.p2g_connect_response", "qualname": "P2GConnectResponse.__init__", "type": "function", "doc": "<p>Constructor</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>success</strong>:  True, if the connect has been successful, False otherwise</li>\n<li><strong>peer_id</strong>:  uuid of the peer</li>\n<li><strong>peerhost</strong>:  hostname/ip of the peer</li>\n<li><strong>guiport</strong>:  guiport of peer</li>\n<li><strong>logs</strong>:  Pointer to peer's logs memory</li>\n</ul>\n", "signature": "(\n    self,\n    success: bool,\n    peer_id: str,\n    peerhost: str,\n    guiport: int,\n    logs: Dict[str, aol.append_only_log.AppendOnlyLog]\n)", "funcdef": "def"}, {"fullname": "p2g_communication.p2g_connect_response.P2GConnectResponse.success", "modulename": "p2g_communication.p2g_connect_response", "qualname": "P2GConnectResponse.success", "type": "variable", "doc": "<p>Getter for success</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>True if connection OK, False otherwise</p>\n</blockquote>\n", "annotation": ": bool"}, {"fullname": "p2g_communication.p2g_connect_response.P2GConnectResponse.peer_id", "modulename": "p2g_communication.p2g_connect_response", "qualname": "P2GConnectResponse.peer_id", "type": "variable", "doc": "<p>Getter for peer's UUID</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>peer's uuid</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "p2g_communication.p2g_connect_response.P2GConnectResponse.peerhost", "modulename": "p2g_communication.p2g_connect_response", "qualname": "P2GConnectResponse.peerhost", "type": "variable", "doc": "<p>Getter for peer's nameor IP-adress</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "annotation": ": str"}, {"fullname": "p2g_communication.p2g_connect_response.P2GConnectResponse.guiport", "modulename": "p2g_communication.p2g_connect_response", "qualname": "P2GConnectResponse.guiport", "type": "variable", "doc": "<p>Getter for port the peer uses for the connection with the GIO client</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>port number</p>\n</blockquote>\n", "annotation": ": int"}, {"fullname": "p2g_communication.p2g_connect_response.P2GConnectResponse.logs", "modulename": "p2g_communication.p2g_connect_response", "qualname": "P2GConnectResponse.logs", "type": "variable", "doc": "<p>Disctionary of logs the peer knows about</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "annotation": ": Dict[str, aol.append_only_log.AppendOnlyLog]"}, {"fullname": "p2g_communication.p2g_create_log_entry_response", "modulename": "p2g_communication.p2g_create_log_entry_response", "type": "module", "doc": "<p>Response to the creation of a log entry</p>\n"}, {"fullname": "p2g_communication.p2g_create_log_entry_response.P2GCreateLogEntryResponse", "modulename": "p2g_communication.p2g_create_log_entry_response", "qualname": "P2GCreateLogEntryResponse", "type": "class", "doc": "<p>Response to the creation of a log entry</p>\n", "bases": "p2g_communication.p2g_communication_interface.P2GCommunicationInterface"}, {"fullname": "p2g_communication.p2g_create_log_entry_response.P2GCreateLogEntryResponse.__init__", "modulename": "p2g_communication.p2g_create_log_entry_response", "qualname": "P2GCreateLogEntryResponse.__init__", "type": "function", "doc": "<p>Constructor</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>log_id</strong>:  ID of the log the entry has been created in</li>\n<li><strong>entry_num</strong>:  index of the newly created entry</li>\n</ul>\n", "signature": "(self, log_id: str, entry_num: int)", "funcdef": "def"}, {"fullname": "p2g_communication.p2g_create_log_entry_response.P2GCreateLogEntryResponse.entry_num", "modulename": "p2g_communication.p2g_create_log_entry_response", "qualname": "P2GCreateLogEntryResponse.entry_num", "type": "variable", "doc": "<p>Getter for the entry index</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>entry index</p>\n</blockquote>\n", "annotation": ": int"}, {"fullname": "p2g_communication.p2g_create_log_entry_response.P2GCreateLogEntryResponse.log_id", "modulename": "p2g_communication.p2g_create_log_entry_response", "qualname": "P2GCreateLogEntryResponse.log_id", "type": "variable", "doc": "<p>Getter for the log id</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "annotation": ": str"}, {"fullname": "p2g_communication.p2g_create_log_response", "modulename": "p2g_communication.p2g_create_log_response", "type": "module", "doc": "<p>Implements the response to a create log command</p>\n"}, {"fullname": "p2g_communication.p2g_create_log_response.P2GCreateLogResponse", "modulename": "p2g_communication.p2g_create_log_response", "qualname": "P2GCreateLogResponse", "type": "class", "doc": "<p>Implements the response to a create log command</p>\n", "bases": "p2g_communication.p2g_communication_interface.P2GCommunicationInterface"}, {"fullname": "p2g_communication.p2g_create_log_response.P2GCreateLogResponse.__init__", "modulename": "p2g_communication.p2g_create_log_response", "qualname": "P2GCreateLogResponse.__init__", "type": "function", "doc": "<p>Constructor</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>log</strong>:  The log instance newly created</li>\n</ul>\n", "signature": "(self, log: aol.append_only_log.AppendOnlyLog)", "funcdef": "def"}, {"fullname": "p2g_communication.p2g_create_log_response.P2GCreateLogResponse.log", "modulename": "p2g_communication.p2g_create_log_response", "qualname": "P2GCreateLogResponse.log", "type": "variable", "doc": "<p>Getter for the newly created log instance</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "annotation": ": aol.append_only_log.AppendOnlyLog"}, {"fullname": "p2g_communication.p2g_following_response", "modulename": "p2g_communication.p2g_following_response", "type": "module", "doc": "<p>Implements the response to the GUI if the peer get's a following command so that gui knows the new follower.</p>\n"}, {"fullname": "p2g_communication.p2g_following_response.P2GFollowingResponse", "modulename": "p2g_communication.p2g_following_response", "qualname": "P2GFollowingResponse", "type": "class", "doc": "<p>Response to gui if peer receives a following command. The following command is issued by another peer which\ncontacts the peers it's following</p>\n", "bases": "p2g_communication.p2g_communication_interface.P2GCommunicationInterface"}, {"fullname": "p2g_communication.p2g_following_response.P2GFollowingResponse.__init__", "modulename": "p2g_communication.p2g_following_response", "qualname": "P2GFollowingResponse.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    following: p2p_commands.abstract_p2p_command.AbstractP2PCommand\n)", "funcdef": "def"}, {"fullname": "p2g_communication.p2g_following_response.P2GFollowingResponse.following", "modulename": "p2g_communication.p2g_following_response", "qualname": "P2GFollowingResponse.following", "type": "variable", "doc": "<p>Getter for the following information</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>following information</p>\n</blockquote>\n", "annotation": ": p2p_commands.p2p_following.P2PFollowing"}, {"fullname": "p2g_communication.p2g_get_entry_response", "modulename": "p2g_communication.p2g_get_entry_response", "type": "module", "doc": "<p></p>\n"}, {"fullname": "p2g_communication.p2g_get_entry_response.P2GGetLogEntryResponse", "modulename": "p2g_communication.p2g_get_entry_response", "qualname": "P2GGetLogEntryResponse", "type": "class", "doc": "<p>Abstract class implementing the interface for commands from the peer node to the GUI client</p>\n", "bases": "p2g_communication.p2g_communication_interface.P2GCommunicationInterface"}, {"fullname": "p2g_communication.p2g_get_entry_response.P2GGetLogEntryResponse.__init__", "modulename": "p2g_communication.p2g_get_entry_response", "qualname": "P2GGetLogEntryResponse.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    entry: Optional[aol.append_only_log_entry.AppendOnlyLogEntry] = None\n)", "funcdef": "def"}, {"fullname": "p2g_communication.p2g_get_entry_response.P2GGetLogEntryResponse.entry", "modulename": "p2g_communication.p2g_get_entry_response", "qualname": "P2GGetLogEntryResponse.entry", "type": "variable", "doc": "<p></p>\n", "annotation": ": aol.append_only_log_entry.AppendOnlyLogEntry"}, {"fullname": "p2g_communication.p2g_get_followers_response", "modulename": "p2g_communication.p2g_get_followers_response", "type": "module", "doc": "<p>Response to \"get followers\" request</p>\n"}, {"fullname": "p2g_communication.p2g_get_followers_response.P2GGetFollowersResponse", "modulename": "p2g_communication.p2g_get_followers_response", "qualname": "P2GGetFollowersResponse", "type": "class", "doc": "<p>Response to \"get followers\" request</p>\n", "bases": "p2g_communication.p2g_communication_interface.P2GCommunicationInterface"}, {"fullname": "p2g_communication.p2g_get_followers_response.P2GGetFollowersResponse.__init__", "modulename": "p2g_communication.p2g_get_followers_response", "qualname": "P2GGetFollowersResponse.__init__", "type": "function", "doc": "<p>Constructor</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>followers</strong>:  List of followers</li>\n</ul>\n", "signature": "(self, followers: List[str])", "funcdef": "def"}, {"fullname": "p2g_communication.p2g_get_followers_response.P2GGetFollowersResponse.followers", "modulename": "p2g_communication.p2g_get_followers_response", "qualname": "P2GGetFollowersResponse.followers", "type": "variable", "doc": "<p>Getter for list of followers</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>List of followers</p>\n</blockquote>\n", "annotation": ": List[str]"}, {"fullname": "p2g_communication.p2g_ping_response", "modulename": "p2g_communication.p2g_ping_response", "type": "module", "doc": "<p>Message to GUI if a Ping echo gets in</p>\n"}, {"fullname": "p2g_communication.p2g_ping_response.P2GPingResponse", "modulename": "p2g_communication.p2g_ping_response", "qualname": "P2GPingResponse", "type": "class", "doc": "<p>Message to GUI if a Ping echo get's in</p>\n", "bases": "p2g_communication.p2g_communication_interface.P2GCommunicationInterface"}, {"fullname": "p2g_communication.p2g_ping_response.P2GPingResponse.__init__", "modulename": "p2g_communication.p2g_ping_response", "qualname": "P2GPingResponse.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, ping: p2p_commands.abstract_p2p_command.AbstractP2PCommand)", "funcdef": "def"}, {"fullname": "p2g_communication.p2g_ping_response.P2GPingResponse.ping", "modulename": "p2g_communication.p2g_ping_response", "qualname": "P2GPingResponse.ping", "type": "variable", "doc": "<p>Getter for ping info</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Ping info</p>\n</blockquote>\n", "annotation": ": p2p_commands.ping.Ping"}, {"fullname": "p2g_communication.p2g_stop_audio_stream_response", "modulename": "p2g_communication.p2g_stop_audio_stream_response", "type": "module", "doc": "<p>Peer received \"stop audio stream\" and forwards this message to the GUI</p>\n"}, {"fullname": "p2g_communication.p2g_stop_audio_stream_response.P2GStopAudioStreamResponse", "modulename": "p2g_communication.p2g_stop_audio_stream_response", "qualname": "P2GStopAudioStreamResponse", "type": "class", "doc": "<p>Peer received \"stop audio stream\" and forwards this message to the GUI</p>\n", "bases": "p2g_communication.p2g_communication_interface.P2GCommunicationInterface"}, {"fullname": "p2g_communication.p2g_stop_audio_stream_response.P2GStopAudioStreamResponse.__init__", "modulename": "p2g_communication.p2g_stop_audio_stream_response", "qualname": "P2GStopAudioStreamResponse.__init__", "type": "function", "doc": "<p>Constructor</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>log_id</strong>:  log id of the AOL that transports this audio stream</li>\n</ul>\n", "signature": "(self, log_id: str)", "funcdef": "def"}, {"fullname": "p2g_communication.p2g_stop_audio_stream_response.P2GStopAudioStreamResponse.log_id", "modulename": "p2g_communication.p2g_stop_audio_stream_response", "qualname": "P2GStopAudioStreamResponse.log_id", "type": "variable", "doc": "<p>Getter for the log ID of the AOL carrying the audio stream</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>log ID</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "p2g_communication.p2p_start_audio_stream_response", "modulename": "p2g_communication.p2p_start_audio_stream_response", "type": "module", "doc": "<p>Implementation of message to GUI client to start an audio stream</p>\n"}, {"fullname": "p2g_communication.p2p_start_audio_stream_response.P2GStartAudioStreamResponse", "modulename": "p2g_communication.p2p_start_audio_stream_response", "qualname": "P2GStartAudioStreamResponse", "type": "class", "doc": "<p>Implementation of message to GUI client to start an audio stream. For more details see echo_peer parameter of\nconstructor</p>\n", "bases": "p2g_communication.p2g_communication_interface.P2GCommunicationInterface"}, {"fullname": "p2g_communication.p2p_start_audio_stream_response.P2GStartAudioStreamResponse.__init__", "modulename": "p2g_communication.p2p_start_audio_stream_response", "qualname": "P2GStartAudioStreamResponse.__init__", "type": "function", "doc": "<p>Constructor</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>log_id</strong>:  ID of the log that carries the audio stream</li>\n<li><strong>echo_peer</strong>:  hostname/IP-address of the originating peer of the stream. It's the string 'ECHO' of it's\n              the answering stream. E.g. peer A initiates a stream and peer B receives the start entry.\n              Then B sends this package with peer A's hostname/IP to its GUI. Then B sends a start\n              stream entry to A to establish the return stream. A sends then a P2PStartAudioStreamResponse\n              to it's GUI with echo_peer set to 'ECHO'.</li>\n</ul>\n", "signature": "(self, log_id: str, echo_peer: str)", "funcdef": "def"}, {"fullname": "p2g_communication.p2p_start_audio_stream_response.P2GStartAudioStreamResponse.log_id", "modulename": "p2g_communication.p2p_start_audio_stream_response", "qualname": "P2GStartAudioStreamResponse.log_id", "type": "variable", "doc": "<p>Getter of log ID of log that carries the audio stream</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>log ID</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "p2g_communication.p2p_start_audio_stream_response.P2GStartAudioStreamResponse.echo_peer", "modulename": "p2g_communication.p2p_start_audio_stream_response", "qualname": "P2GStartAudioStreamResponse.echo_peer", "type": "variable", "doc": "<p>Getter of the echo peer (hostname/IP-Address)</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "annotation": ": str"}, {"fullname": "p2p_commands", "modulename": "p2p_commands", "type": "module", "doc": "<p>This module implements the p2p commands/messages</p>\n"}, {"fullname": "p2p_commands.P2PShutdown", "modulename": "p2p_commands.P2PShutdown", "type": "module", "doc": "<p>Advertise shutdown to followers</p>\n"}, {"fullname": "p2p_commands.P2PShutdown.P2PShutdown", "modulename": "p2p_commands.P2PShutdown", "qualname": "P2PShutdown", "type": "class", "doc": "<p>In case of a regular shutdown, his command is sent to all peers this node is following. They are advised to remove\nthis node from the list of followers.</p>\n", "bases": "p2p_commands.p2p_command.P2PCommand"}, {"fullname": "p2p_commands.P2PShutdown.P2PShutdown.__init__", "modulename": "p2p_commands.P2PShutdown", "qualname": "P2PShutdown.__init__", "type": "function", "doc": "<p>Constructor</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>host</strong>:  hostname/IP adress of node sending this command</li>\n<li><strong>port</strong>:  port number of node sending this command</li>\n</ul>\n", "signature": "(self, host: str, port: int)", "funcdef": "def"}, {"fullname": "p2p_commands.P2PShutdown.P2PShutdown.action", "modulename": "p2p_commands.P2PShutdown", "qualname": "P2PShutdown.action", "type": "function", "doc": "<p>This method is executed on the receiving peer. It removes the advertised node from the list of followers.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>configuration</strong>:   QUIC outgoing configuration</li>\n<li><strong>reader</strong>:  QUIC stream (reading)</li>\n<li><strong>writer</strong>:  QUIC stream (writing)</li>\n<li><strong>followers</strong>:  List of followers of the receiving node</li>\n<li><strong>kwargs</strong>:  other arguments</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    self,\n    configuration: aioquic.quic.configuration.QuicConfiguration,\n    reader: asyncio.streams.StreamReader,\n    writer: asyncio.streams.StreamWriter,\n    followers: Optional[List[p2p_tools.p2p_quic_connection.P2PQuicConnection]] = None,\n    **kwargs\n) -> Optional[p2p_commands.abstract_p2p_command.AbstractP2PCommand]", "funcdef": "async def"}, {"fullname": "p2p_commands.P2PShutdown.P2PShutdown.host", "modulename": "p2p_commands.P2PShutdown", "qualname": "P2PShutdown.host", "type": "variable", "doc": "<p>Getter for hostname/IP-Adress</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>hostname</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "p2p_commands.P2PShutdown.P2PShutdown.port", "modulename": "p2p_commands.P2PShutdown", "qualname": "P2PShutdown.port", "type": "variable", "doc": "<p>Getter for port number</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>port number</p>\n</blockquote>\n", "annotation": ": int"}, {"fullname": "p2p_commands.abstract_p2p_command", "modulename": "p2p_commands.abstract_p2p_command", "type": "module", "doc": "<p>Implements the P2PCommand interface as abstract class</p>\n"}, {"fullname": "p2p_commands.abstract_p2p_command.AbstractP2PCommand", "modulename": "p2p_commands.abstract_p2p_command", "qualname": "AbstractP2PCommand", "type": "class", "doc": "<p>This class is a pure interface class. It is used to define the structure of a command object.</p>\n", "bases": "abc.ABC"}, {"fullname": "p2p_commands.abstract_p2p_command.AbstractP2PCommand.action", "modulename": "p2p_commands.abstract_p2p_command", "qualname": "AbstractP2PCommand.action", "type": "function", "doc": "<p>This outlines the frame of an action that a command objects needs to have. The action methode that is\nimplemented by each p2pcommand is automatically called by the PeerNode when a command object is received on\nthe aioquic server. It implements the action that has to be performed when a peer receives a command object.</p>\n\n<p>It returns itself if it is expected that a GUI response should be generated. The peer node implementation\ntakes care of this if it is aware of the specific command. If no response command should be sent to the\nGIO client, None must be returned.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>configuration</strong>:  The configuration needed to establish a QUIC connection.</li>\n<li><strong>reader</strong>:  The reader of the current QUIC stream.</li>\n<li><strong>writer</strong>:  The writer of the current QUIC stream.</li>\n<li><strong>kwargs</strong>:  All the rest of the qrguments. Classes that are derived from this P2PCommand interface, might need\nmore parameters than defined in this interface. The **kwargs handles them.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Depends on the subclass</p>\n</blockquote>\n", "signature": "(\n    self,\n    configuration: aioquic.quic.configuration.QuicConfiguration,\n    reader: asyncio.streams.StreamReader,\n    writer: asyncio.streams.StreamWriter,\n    **kwargs\n) -> Optional[p2p_commands.abstract_p2p_command.AbstractP2PCommand]", "funcdef": "async def"}, {"fullname": "p2p_commands.command_manager", "modulename": "p2p_commands.command_manager", "type": "module", "doc": "<p>Implements a function that reads data from a QUIC stream and returns the command class instance</p>\n"}, {"fullname": "p2p_commands.command_manager.create_cmdobj", "modulename": "p2p_commands.command_manager", "qualname": "create_cmdobj", "type": "function", "doc": "<p>This function reads bytes from an input stream (expecting a serialized subclass of a P2PCommand object),\ndeserializes the data read and returns the appropriate P2PCommand object. These objects are used to determine the reaction of a peer node.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>reader</strong>:  The reader of the current QUIC stream</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The command object instance</p>\n</blockquote>\n", "signature": "(\n    reader: asyncio.streams.StreamReader,\n    writer: asyncio.streams.StreamWriter\n) -> p2p_commands.abstract_p2p_command.AbstractP2PCommand", "funcdef": "async def"}, {"fullname": "p2p_commands.frontier", "modulename": "p2p_commands.frontier", "type": "module", "doc": "<p>Implements the frontier info</p>\n"}, {"fullname": "p2p_commands.frontier.Frontier", "modulename": "p2p_commands.frontier", "qualname": "Frontier", "type": "class", "doc": "<p>This class represents a frontier. A frontier is the log id and the length (number of entries) of one log. There\nare several different magic functions implemented which allow directly to compare two frontiers.</p>\n"}, {"fullname": "p2p_commands.frontier.Frontier.__init__", "modulename": "p2p_commands.frontier", "qualname": "Frontier.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, log_id: str, log_len: int)", "funcdef": "def"}, {"fullname": "p2p_commands.frontier.Frontier.log_id", "modulename": "p2p_commands.frontier", "qualname": "Frontier.log_id", "type": "variable", "doc": "<p>Getter for log ID</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>log ID</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "p2p_commands.frontier.Frontier.log_len", "modulename": "p2p_commands.frontier", "qualname": "Frontier.log_len", "type": "variable", "doc": "<p>Getter for the log length (number of entries in log)</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "annotation": ": int"}, {"fullname": "p2p_commands.init", "modulename": "p2p_commands.init", "type": "module", "doc": "<p>Implements the Init command which is necessary to overcome a bug/feature of aioquic: A new stream is only instantiated\nafter the first data has been sent. Therefore, after opening a new stream, an Init-command is sent to activate the\nstream.</p>\n"}, {"fullname": "p2p_commands.init.Init", "modulename": "p2p_commands.init", "qualname": "Init", "type": "class", "doc": "<p>This class is used for sending an init object from a peer to another peer. Aioquic has the problem that a new stream\nis only opened upon the first data being sent. Thus, after calling \"create_stream()\" an initial data package has to\nbe sent before the next \"create_stream()\" can be called. Thus, the Init command is used for this. It also sends\nthe address info (host/port) of the initiating peer. It has the serializer class as decorator, that enables the\nserialization and deserialization to/from json.</p>\n", "bases": "p2p_commands.abstract_p2p_command.AbstractP2PCommand"}, {"fullname": "p2p_commands.init.Init.__init__", "modulename": "p2p_commands.init", "qualname": "Init.__init__", "type": "function", "doc": "<p>Constructor</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>sender_addr</strong>:  The IP address of the sending party (originating peer)</li>\n</ul>\n", "signature": "(self, sender_addr: Optional[str] = None)", "funcdef": "def"}, {"fullname": "p2p_commands.init.Init.action", "modulename": "p2p_commands.init", "qualname": "Init.action", "type": "function", "doc": "<p>The action methode is needed, so that the init object conforms to the P2PCommand interface. But since an init object\nis just sent from one peer to the other to initialize a stream, no action is actually executed.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>configuration</strong>:  The QUIC configuration</li>\n<li><strong>reader</strong>:  The reader of the current QUIC stream</li>\n<li><strong>writer</strong>:  The writer of the current QUIC stream</li>\n<li><strong>kwargs</strong>:  All the rest of the arguments that might be given. The can be ignored since this action function\ndoes nothing</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    self,\n    configuration: aioquic.quic.configuration.QuicConfiguration,\n    reader: asyncio.streams.StreamReader,\n    writer: asyncio.streams.StreamWriter,\n    **kwargs\n) -> None", "funcdef": "async def"}, {"fullname": "p2p_commands.init.Init.sender_addr", "modulename": "p2p_commands.init", "qualname": "Init.sender_addr", "type": "variable", "doc": "<p>Getter for timestamp</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>timstamp string</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "p2p_commands.p2p_broadcast", "modulename": "p2p_commands.p2p_broadcast", "type": "module", "doc": "<p></p>\n"}, {"fullname": "p2p_commands.p2p_broadcast.P2PBroadcast", "modulename": "p2p_commands.p2p_broadcast", "qualname": "P2PBroadcast", "type": "class", "doc": "<p>This abstract class manages all the functionalities that rely on a broadcast throughout the p2p network. It's the\nbased class for all commands that use the broadcast mechanism. It uses a time to live (ttl) to determine how far\nin the network a message should be broadcast. It is derived from the P2PCommand interface. All instances of\nP2PBroadcast subclasses to have a unique UUID that identifies the specific command as it floods the network. It is\nused to prevent looping etc.</p>\n\n<p>A P2Pbroadcast command traversing the network also stored all peers it has passed in the _senders member\nvariables and traces it's path through the network</p>\n\n<p>Subclasses must implement the action method. It has to deal with the ttl using the decrement method and add it's\ncorresponding peer to the list of senders using the senders_append method.</p>\n", "bases": "p2p_commands.p2p_command.P2PCommand"}, {"fullname": "p2p_commands.p2p_broadcast.P2PBroadcast.__init__", "modulename": "p2p_commands.p2p_broadcast", "qualname": "P2PBroadcast.__init__", "type": "function", "doc": "<p>Constructor used by de-serializer</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ttl</strong>:  Time to live. The \"reach\" of a broadcast object</li>\n<li><strong>uid</strong>:  The uuid of a broadcast object. Used to identify a specific broadcast object</li>\n<li><strong>senders</strong>:  List of the senders chain. Represents the path through the network that has been taken yet</li>\n<li><strong>is_response</strong>:  True if it is a package on its return path. Sofar only used in ping. If true, it's not forwarded to any follower, only to\nthe previous sender</li>\n</ul>\n", "signature": "(\n    self,\n    ttl: int,\n    uid: Optional[uuid.UUID] = None,\n    senders: Optional[List[str]] = None,\n    is_response: bool = False\n)", "funcdef": "def"}, {"fullname": "p2p_commands.p2p_broadcast.P2PBroadcast.uid", "modulename": "p2p_commands.p2p_broadcast", "qualname": "P2PBroadcast.uid", "type": "variable", "doc": "<p>getter for UUID</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>uuid string of command</p>\n</blockquote>\n", "annotation": ": uuid.UUID"}, {"fullname": "p2p_commands.p2p_broadcast.P2PBroadcast.ttl", "modulename": "p2p_commands.p2p_broadcast", "qualname": "P2PBroadcast.ttl", "type": "variable", "doc": "<p>Getter for time to live</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>ttl</p>\n</blockquote>\n", "annotation": ": int"}, {"fullname": "p2p_commands.p2p_broadcast.P2PBroadcast.decrement", "modulename": "p2p_commands.p2p_broadcast", "qualname": "P2PBroadcast.decrement", "type": "function", "doc": "<p>Used to decrement the ttl by 1. Gets called after every hop from one peer node to another</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The new ttl</p>\n</blockquote>\n", "signature": "(self) -> int", "funcdef": "def"}, {"fullname": "p2p_commands.p2p_broadcast.P2PBroadcast.senders_append", "modulename": "p2p_commands.p2p_broadcast", "qualname": "P2PBroadcast.senders_append", "type": "function", "doc": "<p></p>\n", "signature": "(self, my_addr: str) -> None", "funcdef": "def"}, {"fullname": "p2p_commands.p2p_command", "modulename": "p2p_commands.p2p_command", "type": "module", "doc": "<p>This module implements the P2PCommand class</p>\n"}, {"fullname": "p2p_commands.p2p_command.P2PCommand", "modulename": "p2p_commands.p2p_command", "qualname": "P2PCommand", "type": "class", "doc": "<p>This is the superclass of all commands that need to have a \"forward\" functionality. Forwarding means that the command object is forwarded to all\nfollowers as long as ttl is &gt; 0.</p>\n", "bases": "p2p_commands.abstract_p2p_command.AbstractP2PCommand"}, {"fullname": "p2p_commands.p2p_command.P2PCommand.p2p_forward", "modulename": "p2p_commands.p2p_command", "qualname": "P2PCommand.p2p_forward", "type": "function", "doc": "<p>This methode is used to forward self to a follower</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>follower</strong>:  One follower of the peer that uses this methode</li>\n<li><strong>my_addr</strong>:  My host and port number. Sender information (e.g. for backtracking purposes)</li>\n<li><strong>additional_communication</strong>:  In some cases, after the forwarding some additional functionalities are necessary. E.g. for requesting\nmissing information. The additional_communication parameter is usually a function or methode that performes these actions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Returns None, if every worked and the command could be forwarded.\n           Returns the follower (type P2PQuicConnection) if this follower could not be reached</p>\n</blockquote>\n", "signature": "(\n    self,\n    follower: p2p_tools.p2p_quic_connection.P2PQuicConnection,\n    *,\n    log_id: Optional[str] = None,\n    my_addr: Optional[str] = None,\n    additional_communication: Optional[Any] = None\n) -> None | p2p_tools.p2p_quic_connection.P2PQuicConnection", "funcdef": "async def"}, {"fullname": "p2p_commands.p2p_following", "modulename": "p2p_commands.p2p_following", "type": "module", "doc": "<p>Implements the following command which a peer uses to inform other peer that it is following them.</p>\n"}, {"fullname": "p2p_commands.p2p_following.P2PFollowing", "modulename": "p2p_commands.p2p_following", "qualname": "P2PFollowing", "type": "class", "doc": "<p>Class that implements the command which a peer uses to inform other peer that it is following them. A node\nsends this command to peer that it wants to follow. In this case the parameter \"init\" must be True.\nIf the receiving peer also want's to follow this node, it also sends a P2PFollowing command, but this time\nwith the parameter \"init\" set to False. This an indefinite ping-pong is prevented.</p>\n", "bases": "p2p_commands.p2p_command.P2PCommand"}, {"fullname": "p2p_commands.p2p_following.P2PFollowing.__init__", "modulename": "p2p_commands.p2p_following", "qualname": "P2PFollowing.__init__", "type": "function", "doc": "<p>Constructor</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>host</strong>:  Hostname/IP of the sending peer</li>\n<li><strong>port</strong>:  port number of the sending peer</li>\n<li><strong>init</strong>:  True, if this is the initial command. On return False</li>\n</ul>\n", "signature": "(self, host: str, port: int, init: bool)", "funcdef": "def"}, {"fullname": "p2p_commands.p2p_following.P2PFollowing.action", "modulename": "p2p_commands.p2p_following", "qualname": "P2PFollowing.action", "type": "function", "doc": "<p>Implementation of the action method for the P2PFollowing command. The action is executed on the peer\nthat receives a following command.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>configuration</strong>:  Outgoing QuicConfiguration</li>\n<li><strong>reader</strong>:  QUIC input stream</li>\n<li><strong>writer</strong>:  QUIC output stream</li>\n<li><strong>followers</strong>:  List of followers</li>\n<li><strong>kwargs</strong>:  More arguments</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None, if no GUI response should be sent, self otherwise</p>\n</blockquote>\n", "signature": "(\n    self,\n    configuration: aioquic.quic.configuration.QuicConfiguration,\n    reader: asyncio.streams.StreamReader,\n    writer: asyncio.streams.StreamWriter,\n    followers: Optional[List[p2p_tools.p2p_quic_connection.P2PQuicConnection]] = None,\n    **kwargs\n) -> Optional[p2p_commands.abstract_p2p_command.AbstractP2PCommand]", "funcdef": "async def"}, {"fullname": "p2p_commands.p2p_following.P2PFollowing.init", "modulename": "p2p_commands.p2p_following", "qualname": "P2PFollowing.init", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool"}, {"fullname": "p2p_commands.p2p_following.P2PFollowing.host", "modulename": "p2p_commands.p2p_following", "qualname": "P2PFollowing.host", "type": "variable", "doc": "<p>Getter for hostname/IP-Adress</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>hostname</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "p2p_commands.p2p_following.P2PFollowing.port", "modulename": "p2p_commands.p2p_following", "qualname": "P2PFollowing.port", "type": "variable", "doc": "<p>Getter for port number</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>port number</p>\n</blockquote>\n", "annotation": ": int"}, {"fullname": "p2p_commands.p2p_frontier_pull", "modulename": "p2p_commands.p2p_frontier_pull", "type": "module", "doc": "<p>Implements the FrontierPull command which is used to get the frontier from the peers this node is following and\nupdate this node's logs.</p>\n"}, {"fullname": "p2p_commands.p2p_frontier_pull.P2PFrontierPull", "modulename": "p2p_commands.p2p_frontier_pull", "qualname": "P2PFrontierPull", "type": "class", "doc": "<p>This command class is used to orientate this node about all news of the peers it is following. A frontier pull\nworks like the following sequence:</p>\n\n<ul>\n<li>First the peer that wants the update of the frontiers sends his frontier to the nodes he is following.</li>\n<li>The nodes he is following (TRUMP) calculate the difference between their frontier and the received frontier from\nthis node.</li>\n<li>Then the nodes it is following (TRUMP) send the information back to this node as to what it needs to request.</li>\n<li>The follower (this node) thenrequests then the missing logs/entries. (Reason being: See this Action)</li>\n</ul>\n", "bases": "p2p_commands.p2p_command.P2PCommand"}, {"fullname": "p2p_commands.p2p_frontier_pull.P2PFrontierPull.__init__", "modulename": "p2p_commands.p2p_frontier_pull", "qualname": "P2PFrontierPull.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    frontiers: List[p2p_commands.frontier.Frontier],\n    logs: Optional[Dict[str, aol.append_only_log.AppendOnlyLog]] = None,\n    followers: Optional[List[p2p_tools.p2p_quic_connection.P2PQuicConnection]] = None,\n    outgoing_config: Optional[aioquic.quic.configuration.QuicConfiguration] = None\n)", "funcdef": "def"}, {"fullname": "p2p_commands.p2p_frontier_pull.P2PFrontierPull.frontier_pull_communication", "modulename": "p2p_commands.p2p_frontier_pull", "qualname": "P2PFrontierPull.frontier_pull_communication", "type": "function", "doc": "<p>This is the additional communication that will take place in the follower after the action took place in the following.\n(This is a fan of TRUMP who is following TRUMP)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>reader</strong>:  QUIC reader</li>\n<li><strong>writer</strong>:  QUIC writer</li>\n<li><strong>peer</strong>:  The QuicConnectionProtocol of this peer. Is needed to create new streams</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    self,\n    reader: asyncio.streams.StreamReader,\n    writer: asyncio.streams.StreamWriter,\n    peer: aioquic.asyncio.protocol.QuicConnectionProtocol\n) -> None", "funcdef": "async def"}, {"fullname": "p2p_commands.p2p_frontier_pull.P2PFrontierPull.action", "modulename": "p2p_commands.p2p_frontier_pull", "qualname": "P2PFrontierPull.action", "type": "function", "doc": "<p>This is the reaction to a frontier pull command that has been sent by a follower. The command contains the\nfrontiers of all logs of the follower. The action now calculates which logs of the follower are missing or\nincomplete/out-of-date and sends this information back to the follower. The follower in turn will then request\nthese updates from this peer.\nThis workaround is needed because the connection got initialized by the follower. As a result ( alimitation of\naioquic) this peer can not use the same connection to initiate new streams. Only the originator of a\nconnection is able to create new streams. The follower then creates new streams for each log using the already\nestablished connection. (This is TRUMP with many followers (people that are following me...))</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>configuration</strong>:  The QUIC configuration necessary for the QUIC connection</li>\n<li><strong>reader</strong>:  The QUIC reader</li>\n<li><strong>writer</strong>:  The QUIC writer</li>\n<li><strong>kwargs</strong>:  Additional parameters</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    self,\n    configuration: aioquic.quic.configuration.QuicConfiguration,\n    reader: asyncio.streams.StreamReader,\n    writer: asyncio.streams.StreamWriter,\n    **kwargs\n) -> Optional[p2p_commands.abstract_p2p_command.AbstractP2PCommand]", "funcdef": "async def"}, {"fullname": "p2p_commands.p2p_frontier_push", "modulename": "p2p_commands.p2p_frontier_push", "type": "module", "doc": "<p>Implements the frontier push command</p>\n"}, {"fullname": "p2p_commands.p2p_frontier_push.P2PFrontierPushData", "modulename": "p2p_commands.p2p_frontier_push", "qualname": "P2PFrontierPushData", "type": "class", "doc": "<p>This class is responsible to push one log including its entries or only entries to another peer.</p>\n", "bases": "p2p_commands.p2p_command.P2PCommand"}, {"fullname": "p2p_commands.p2p_frontier_push.P2PFrontierPushData.__init__", "modulename": "p2p_commands.p2p_frontier_push", "qualname": "P2PFrontierPushData.__init__", "type": "function", "doc": "<p>Constructor for P2PFrontierPushData compatible with @serializer</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>log</strong>:  AOL</li>\n<li><strong>log_id</strong>:  the log ID</li>\n<li><strong>entries</strong>:  List of entries</li>\n</ul>\n", "signature": "(\n    self,\n    *,\n    log: Optional[aol.append_only_log.AppendOnlyLog] = None,\n    log_id: Optional[str] = None,\n    entries: Optional[List[aol.append_only_log_entry.AppendOnlyLogEntry]] = None\n)", "funcdef": "def"}, {"fullname": "p2p_commands.p2p_frontier_push.P2PFrontierPushData.log", "modulename": "p2p_commands.p2p_frontier_push", "qualname": "P2PFrontierPushData.log", "type": "variable", "doc": "<p>Getter for the log instance</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>AOL instance</p>\n</blockquote>\n", "annotation": ": aol.append_only_log.AppendOnlyLog | None"}, {"fullname": "p2p_commands.p2p_frontier_push.P2PFrontierPushData.log_id", "modulename": "p2p_commands.p2p_frontier_push", "qualname": "P2PFrontierPushData.log_id", "type": "variable", "doc": "<p>Getter for the log ID</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>log ID</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "p2p_commands.p2p_frontier_push.P2PFrontierPushData.entries", "modulename": "p2p_commands.p2p_frontier_push", "qualname": "P2PFrontierPushData.entries", "type": "variable", "doc": "<p>Getter for the list of entries</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>List of Entries</p>\n</blockquote>\n", "annotation": ": Optional[List[aol.append_only_log_entry.AppendOnlyLogEntry]]"}, {"fullname": "p2p_commands.p2p_frontier_push.P2PFrontierPushData.action", "modulename": "p2p_commands.p2p_frontier_push", "qualname": "P2PFrontierPushData.action", "type": "function", "doc": "<p>This is called on the receiving end of the P2PFrontierPushData command.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>configuration</strong>:  QUIC connection configuration</li>\n<li><strong>reader</strong>:  QUIC reader</li>\n<li><strong>writer</strong>:  QUIC writer</li>\n<li><strong>kwargs</strong>:  Other parameters</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    self,\n    configuration: aioquic.quic.configuration.QuicConfiguration,\n    reader: asyncio.streams.StreamReader,\n    writer: asyncio.streams.StreamWriter,\n    **kwargs\n) -> Optional[p2p_commands.abstract_p2p_command.AbstractP2PCommand]", "funcdef": "async def"}, {"fullname": "p2p_commands.p2p_frontier_push.P2PFrontierPush", "modulename": "p2p_commands.p2p_frontier_push", "qualname": "P2PFrontierPush", "type": "class", "doc": "<p>This class is used when a peer newly re-enters the network. It pushes its own frontier to the followers to see if they need an update on its logs.\nFirst the frontier is pushed to the followers. Then they calculate what they are missing and send this information back to this peer. Then\nthis peer sends the missing logs/entries.</p>\n", "bases": "p2p_commands.p2p_command.P2PCommand"}, {"fullname": "p2p_commands.p2p_frontier_push.P2PFrontierPush.__init__", "modulename": "p2p_commands.p2p_frontier_push", "qualname": "P2PFrontierPush.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    frontiers: List[p2p_commands.frontier.Frontier],\n    logs: Optional[Dict[str, aol.append_only_log.AppendOnlyLog]] = None\n)", "funcdef": "def"}, {"fullname": "p2p_commands.p2p_frontier_push.P2PFrontierPush.frontier_push_communication", "modulename": "p2p_commands.p2p_frontier_push", "qualname": "P2PFrontierPush.frontier_push_communication", "type": "function", "doc": "<p>This additional communication gets called again from the initiator of the P2PFrontierPush (newly re-entered node) and responds to the request\nfrom the action that was executed in the follower. It gets the frontier that has to be pushed to the follower.\nThis is TRUMP</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>reader</strong>:  QUIC reader</li>\n<li><strong>writer</strong>:  QUIC writer</li>\n<li><strong>peer</strong>:  QuicConnectionProtocol instance of the peer</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    self,\n    reader: asyncio.streams.StreamReader,\n    writer: asyncio.streams.StreamWriter,\n    peer: aioquic.asyncio.protocol.QuicConnectionProtocol\n) -> None", "funcdef": "async def"}, {"fullname": "p2p_commands.p2p_frontier_push.P2PFrontierPush.action", "modulename": "p2p_commands.p2p_frontier_push", "qualname": "P2PFrontierPush.action", "type": "function", "doc": "<p>This is the action that gets executed when the follower receives a frontier push message from the newly entered node.\nThis is a follower of TRUMP</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>configuration</strong>:  QUIc connection configuration</li>\n<li><strong>reader</strong>:  QUIC reader</li>\n<li><strong>writer</strong>:  QUIC writer</li>\n<li><strong>kwargs</strong>:  Additional arguments (e.g. frontiers)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    self,\n    configuration: aioquic.quic.configuration.QuicConfiguration,\n    reader: asyncio.streams.StreamReader,\n    writer: asyncio.streams.StreamWriter,\n    **kwargs\n) -> Optional[p2p_commands.abstract_p2p_command.AbstractP2PCommand]", "funcdef": "async def"}, {"fullname": "p2p_commands.p2p_get_logs", "modulename": "p2p_commands.p2p_get_logs", "type": "module", "doc": "<p>Implements the command to retrieve the logs from a peer</p>\n"}, {"fullname": "p2p_commands.p2p_get_logs.P2PGetOneLog", "modulename": "p2p_commands.p2p_get_logs", "qualname": "P2PGetOneLog", "type": "class", "doc": "<p>This command class is used to request a specific log or all entries from a starting index from a peer</p>\n", "bases": "p2p_commands.abstract_p2p_command.AbstractP2PCommand"}, {"fullname": "p2p_commands.p2p_get_logs.P2PGetOneLog.__init__", "modulename": "p2p_commands.p2p_get_logs", "qualname": "P2PGetOneLog.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, log_id: str, from_index: Optional[int] = -1)", "funcdef": "def"}, {"fullname": "p2p_commands.p2p_get_logs.P2PGetOneLog.action", "modulename": "p2p_commands.p2p_get_logs", "qualname": "P2PGetOneLog.action", "type": "function", "doc": "<p>The action of the receiver of the P2PGetOneLog. Gets executed as consequence of the P2PGetOneLog command</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>configuration</strong>:  QUIc connection configuration</li>\n<li><strong>reader</strong>:  QUIC reader</li>\n<li><strong>writer</strong>:  QUIC writer</li>\n<li><strong>kwargs</strong>:  Additional parameters</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    self,\n    configuration: aioquic.quic.configuration.QuicConfiguration,\n    reader: asyncio.streams.StreamReader,\n    writer: asyncio.streams.StreamWriter,\n    **kwargs\n) -> Optional[p2p_commands.abstract_p2p_command.AbstractP2PCommand]", "funcdef": "async def"}, {"fullname": "p2p_commands.p2p_get_logs.p2p_request_logs", "modulename": "p2p_commands.p2p_get_logs", "qualname": "p2p_request_logs", "type": "function", "doc": "<p>This function requests the logs defined in the frontiers list(parameter). For each log a new stream is established.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>frontiers</strong>:  List of frontiers to request</li>\n<li><strong>peer</strong>:  QuicConnectionProtocol of this peer</li>\n<li><strong>followers</strong>:  List of followers of this peer</li>\n<li><strong>outgoing_config</strong>:  Configuration for the QUIC connection</li>\n<li><strong>logs</strong>:  Bookkeeping list of this peer. Needed to update the list of logs that are visible in the memory (for e.g. GUI)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>List of the aol instances that were requested</p>\n</blockquote>\n", "signature": "(\n    frontiers: List[p2p_commands.frontier.Frontier],\n    peer: aioquic.asyncio.protocol.QuicConnectionProtocol,\n    followers: List[p2p_tools.p2p_quic_connection.P2PQuicConnection],\n    outgoing_config: aioquic.quic.configuration.QuicConfiguration,\n    logs: Dict[str, aol.append_only_log.AppendOnlyLog]\n) -> List[aol.append_only_log.AppendOnlyLog]", "funcdef": "async def"}, {"fullname": "p2p_commands.p2p_log_entry_push", "modulename": "p2p_commands.p2p_log_entry_push", "type": "module", "doc": "<p>This module implements the command to add an entry to a log.</p>\n"}, {"fullname": "p2p_commands.p2p_log_entry_push.P2PLogEntryPush", "modulename": "p2p_commands.p2p_log_entry_push", "qualname": "P2PLogEntryPush", "type": "class", "doc": "<p>This command class is used to push an entry to followers. It deals with the problem that the receiving peer may have a log which is outdated\nand first needs additional, previous entries before adding the pushed one.</p>\n", "bases": "p2p_commands.p2p_broadcast.P2PBroadcast"}, {"fullname": "p2p_commands.p2p_log_entry_push.P2PLogEntryPush.__init__", "modulename": "p2p_commands.p2p_log_entry_push", "qualname": "P2PLogEntryPush.__init__", "type": "function", "doc": "<p>Constructor used by de-serializer</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ttl</strong>:  Time to live. The \"reach\" of a broadcast object</li>\n<li><strong>uid</strong>:  The uuid of a broadcast object. Used to identify a specific broadcast object</li>\n<li><strong>senders</strong>:  List of the senders chain. Represents the path through the network that has been taken yet</li>\n<li><strong>is_response</strong>:  True if it is a package on its return path. Sofar only used in ping. If true, it's not forwarded to any follower, only to\nthe previous sender</li>\n</ul>\n", "signature": "(\n    self,\n    ttl: int,\n    log_id: str,\n    aol_entry: aol.append_only_log_entry.AppendOnlyLogEntry,\n    logs: Optional[Dict[str, aol.append_only_log.AppendOnlyLog]] = None,\n    uid: Optional[uuid.UUID] = None,\n    senders: Optional[List[str]] = None,\n    is_response: bool = False\n)", "funcdef": "def"}, {"fullname": "p2p_commands.p2p_log_entry_push.P2PLogEntryPush.action", "modulename": "p2p_commands.p2p_log_entry_push", "qualname": "P2PLogEntryPush.action", "type": "function", "doc": "<p>this action is called by the receiver of the P2PLogEntryPush command.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>configuration</strong>:  QUIC configuration</li>\n<li><strong>reader</strong>:  QUIC reader</li>\n<li><strong>writer</strong>:  QUIc writer</li>\n<li><strong>followers</strong>:  followers of the receiving peer</li>\n<li><strong>my_addr</strong>:  IP of recieving peer</li>\n<li><strong>from_addr</strong>:  IP of sender peer</li>\n<li><strong>kwargs</strong>:  Additional arguments</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    self,\n    configuration: aioquic.quic.configuration.QuicConfiguration,\n    reader: asyncio.streams.StreamReader,\n    writer: asyncio.streams.StreamWriter,\n    followers: Optional[List[p2p_tools.p2p_quic_connection.P2PQuicConnection]] = None,\n    my_addr: Optional[str] = None,\n    from_addr: Optional[str] = None,\n    **kwargs\n)", "funcdef": "async def"}, {"fullname": "p2p_commands.p2p_log_entry_push.P2PLogEntryPush.aol_entry", "modulename": "p2p_commands.p2p_log_entry_push", "qualname": "P2PLogEntryPush.aol_entry", "type": "variable", "doc": "<p>Getter for entry</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>entry</p>\n</blockquote>\n", "annotation": ": aol.append_only_log_entry.AppendOnlyLogEntry"}, {"fullname": "p2p_commands.p2p_log_entry_push.P2PLogEntryPush.log_id", "modulename": "p2p_commands.p2p_log_entry_push", "qualname": "P2PLogEntryPush.log_id", "type": "variable", "doc": "<p>Getter for log id</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>log ID</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "p2p_commands.p2p_log_push", "modulename": "p2p_commands.p2p_log_push", "type": "module", "doc": "<p>This command implements the log push command which is used to propagate a new log through the network</p>\n"}, {"fullname": "p2p_commands.p2p_log_push.P2PLogPush", "modulename": "p2p_commands.p2p_log_push", "qualname": "P2PLogPush", "type": "class", "doc": "<p>This class handles the log push action</p>\n", "bases": "p2p_commands.p2p_broadcast.P2PBroadcast"}, {"fullname": "p2p_commands.p2p_log_push.P2PLogPush.__init__", "modulename": "p2p_commands.p2p_log_push", "qualname": "P2PLogPush.__init__", "type": "function", "doc": "<p>Constructor used by de-serializer</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ttl</strong>:  Time to live. The \"reach\" of a broadcast object</li>\n<li><strong>uid</strong>:  The uuid of a broadcast object. Used to identify a specific broadcast object</li>\n<li><strong>senders</strong>:  List of the senders chain. Represents the path through the network that has been taken yet</li>\n<li><strong>is_response</strong>:  True if it is a package on its return path. Sofar only used in ping. If true, it's not forwarded to any follower, only to\nthe previous sender</li>\n</ul>\n", "signature": "(\n    self,\n    ttl: int,\n    aol: aol.append_only_log.AppendOnlyLog,\n    uid: Optional[uuid.UUID] = None,\n    senders: Optional[List[str]] = None,\n    is_response: bool = False\n)", "funcdef": "def"}, {"fullname": "p2p_commands.p2p_log_push.P2PLogPush.action", "modulename": "p2p_commands.p2p_log_push", "qualname": "P2PLogPush.action", "type": "function", "doc": "<p>This action is executed when a peer receives a P2PLogPush broadcast. It creates the log and then sends the command further to all its\nfollowers (broadcast)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>configuration</strong>:  QUIC configuration</li>\n<li><strong>reader</strong>:  QUIC reader</li>\n<li><strong>writer</strong>:  QUIC writer</li>\n<li><strong>followers</strong>:  List of followers of the receiver</li>\n<li><strong>my_addr</strong>:  IP adress of the receiver</li>\n<li><strong>from_addr</strong>:  IP adress of the sender</li>\n<li><strong>kwargs</strong>:  Additional arguments</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    self,\n    configuration: aioquic.quic.configuration.QuicConfiguration,\n    reader: asyncio.streams.StreamReader,\n    writer: asyncio.streams.StreamWriter,\n    followers: Optional[List[p2p_tools.p2p_quic_connection.P2PQuicConnection]] = None,\n    my_addr: Optional[str] = None,\n    from_addr: Optional[str] = None,\n    **kwargs\n)", "funcdef": "async def"}, {"fullname": "p2p_commands.p2p_log_push.P2PLogPush.aol", "modulename": "p2p_commands.p2p_log_push", "qualname": "P2PLogPush.aol", "type": "variable", "doc": "<p>getter for AOL</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>AOL</p>\n</blockquote>\n", "annotation": ": aol.append_only_log.AppendOnlyLog"}, {"fullname": "p2p_commands.p2p_noise", "modulename": "p2p_commands.p2p_noise", "type": "module", "doc": "<p>Implementation of a background noise message.</p>\n"}, {"fullname": "p2p_commands.p2p_noise.P2PNoise", "modulename": "p2p_commands.p2p_noise", "qualname": "P2PNoise", "type": "class", "doc": "<p>In order to create a \"background noise\" of traffic, the P2PNoise class implements a packet of data that can be\nbroadcast with no real purpose other than generating network traffic. The payload is randomized as well as the\nfrequency these packages are being transmitted.</p>\n", "bases": "p2p_commands.p2p_broadcast.P2PBroadcast"}, {"fullname": "p2p_commands.p2p_noise.P2PNoise.__init__", "modulename": "p2p_commands.p2p_noise", "qualname": "P2PNoise.__init__", "type": "function", "doc": "<p>Constructor of noise package</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ttl</strong>:  time to live</li>\n<li><strong>payload</strong>:  a random payload</li>\n<li><strong>uid</strong>:  Do not use \u2013 only for serializer</li>\n<li><strong>senders</strong>:  Do not use \u2013 only for serializer</li>\n<li><strong>is_response</strong>:  Do not use \u2013 only for serializer</li>\n</ul>\n", "signature": "(\n    self,\n    ttl: int,\n    payload: bytes,\n    uid: Optional[uuid.UUID] = None,\n    senders: Optional[List[str]] = None,\n    is_response: bool = False\n)", "funcdef": "def"}, {"fullname": "p2p_commands.p2p_noise.P2PNoise.action", "modulename": "p2p_commands.p2p_noise", "qualname": "P2PNoise.action", "type": "function", "doc": "<p>This outlines the frame of an action that a command objects needs to have. The action methode that is\nimplemented by each p2pcommand is automatically called by the PeerNode when a command object is received on\nthe aioquic server. It implements the action that has to be performed when a peer receives a command object.</p>\n\n<p>It returns itself if it is expected that a GUI response should be generated. The peer node implementation\ntakes care of this if it is aware of the specific command. If no response command should be sent to the\nGIO client, None must be returned.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>configuration</strong>:  The configuration needed to establish a QUIC connection.</li>\n<li><strong>reader</strong>:  The reader of the current QUIC stream.</li>\n<li><strong>writer</strong>:  The writer of the current QUIC stream.</li>\n<li><strong>kwargs</strong>:  All the rest of the qrguments. Classes that are derived from this P2PCommand interface, might need\nmore parameters than defined in this interface. The **kwargs handles them.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Depends on the subclass</p>\n</blockquote>\n", "signature": "(\n    self,\n    configuration: aioquic.quic.configuration.QuicConfiguration,\n    reader: asyncio.streams.StreamReader,\n    writer: asyncio.streams.StreamWriter,\n    followers: Optional[List[p2p_tools.p2p_quic_connection.P2PQuicConnection]] = None,\n    my_addr: Optional[str] = None,\n    from_addr: Optional[str] = None,\n    **kwargs\n)", "funcdef": "async def"}, {"fullname": "p2p_commands.ping", "modulename": "p2p_commands.ping", "type": "module", "doc": "<p></p>\n"}, {"fullname": "p2p_commands.ping.Ping", "modulename": "p2p_commands.ping", "qualname": "Ping", "type": "class", "doc": "<p>This class is used for sending a broadcast ping from a peer to its followers and followers of followers\n(until the tile to life - ttf - is reached). This class is a children of the broadcast class, since it uses\nbroadcasts as well. It has an instance of the serializer class as decorator, that enables the serialization and\ndeserialization of a ping object</p>\n", "bases": "p2p_commands.p2p_broadcast.P2PBroadcast"}, {"fullname": "p2p_commands.ping.Ping.__init__", "modulename": "p2p_commands.ping", "qualname": "Ping.__init__", "type": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ttl</strong>:  Time to life. Denotes, how far this particular ping object might still travel inside the p2p network</li>\n<li><strong>timestamp</strong>:  The creation time of the ping object.</li>\n<li><strong>uid</strong>:  The uuid to identify one particular ping object.</li>\n</ul>\n", "signature": "(\n    self,\n    ttl: int,\n    timestamp: Optional[str] = None,\n    uid: Optional[uuid.UUID] = None,\n    senders: Optional[List[str]] = None,\n    is_response: bool = False\n)", "funcdef": "def"}, {"fullname": "p2p_commands.ping.Ping.timestamp", "modulename": "p2p_commands.ping", "qualname": "Ping.timestamp", "type": "variable", "doc": "<p>Returns the member variable _timestamp</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>str</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "p2p_commands.ping.Ping.action", "modulename": "p2p_commands.ping", "qualname": "Ping.action", "type": "function", "doc": "<p>The action that a broadcast object can do.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>configuration</strong>:  The configuration that is necessary for the QUIC connection</li>\n<li><strong>reader</strong>:  The reader of the current QUIc connection</li>\n<li><strong>writer</strong>:  The writer of the current QUIC connection</li>\n<li><strong>followers</strong>:  All the followers of the current peer</li>\n<li><strong>my_addr</strong>:  The IP adress of the current peer</li>\n<li><strong>from_addr</strong>:  Used in subclasses</li>\n<li><strong>kwargs</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Depends on subclass</p>\n</blockquote>\n", "signature": "(\n    self,\n    configuration: aioquic.quic.configuration.QuicConfiguration,\n    reader: asyncio.streams.StreamReader,\n    writer: asyncio.streams.StreamWriter,\n    followers: Optional[List[p2p_tools.p2p_quic_connection.P2PQuicConnection]] = None,\n    my_addr: Optional[str] = None,\n    from_addr: Optional[str] = None,\n    **kwargs\n)", "funcdef": "async def"}, {"fullname": "p2p_tools", "modulename": "p2p_tools", "type": "module", "doc": "<p>This module implements some helpers for the p2p communication.</p>\n"}, {"fullname": "p2p_tools.p2p_protocol", "modulename": "p2p_tools.p2p_protocol", "type": "module", "doc": "<p>Implements some helper classes and functions for the P2PCommand and subclasses. Especially it\nimplements the low level function to send/receive data on the QUIC streams. A data package is always\npreceded by 4 bytes containing the length of the data followed by the actual data. The length is encoded as\n4 bytes binary (big endian)</p>\n"}, {"fullname": "p2p_tools.p2p_protocol.P2PConnectionClosed", "modulename": "p2p_tools.p2p_protocol", "qualname": "P2PConnectionClosed", "type": "class", "doc": "<p>This is an error class. Used to handle P2PConnectionClosed errors.</p>\n", "bases": "builtins.Exception"}, {"fullname": "p2p_tools.p2p_protocol.P2PProtocolError", "modulename": "p2p_tools.p2p_protocol", "qualname": "P2PProtocolError", "type": "class", "doc": "<p>This is my error class. Used to handle P2PProtocolError errors.</p>\n", "bases": "builtins.Exception"}, {"fullname": "p2p_tools.p2p_protocol.P2PProtocolError.__init__", "modulename": "p2p_tools.p2p_protocol", "qualname": "P2PProtocolError.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, message: str)", "funcdef": "def"}, {"fullname": "p2p_tools.p2p_protocol.p2p_init_stream", "modulename": "p2p_tools.p2p_protocol", "qualname": "p2p_init_stream", "type": "function", "doc": "<p>This function is necessary to instantiate a stream-connection between two parties that use a QUIC connection.\nMaybe this is due to a bug that is located inside the aioquic library.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>peer: This peer_node. Important</strong>:  the \"self\" peer_node!</li>\n<li><strong>sender_addr</strong>:  The IP address of the sending party</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Tuple[StreamReader, StreamWriter]</p>\n</blockquote>\n", "signature": "(\n    peer: aioquic.asyncio.protocol.QuicConnectionProtocol | None,\n    sender_addr: Optional[str] = None\n) -> Tuple[asyncio.streams.StreamReader, asyncio.streams.StreamWriter]", "funcdef": "async def"}, {"fullname": "p2p_tools.p2p_protocol.p2p_send_package", "modulename": "p2p_tools.p2p_protocol", "qualname": "p2p_send_package", "type": "function", "doc": "<p>This function is responsible for sending a data package from one peer to the other. It consists of the length (as\nstring) of the payload terminated by a newline. Then payload is sent.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>peer</strong>:  This current peer. Is only needed when data has to be transmitted to a next peer. If data is sent\nback to the other peer, then peer is not given/needed.</li>\n<li><strong>writer</strong>:  The writer of the current stream</li>\n<li><strong>data</strong>:  The data that is to be transmitted</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    reader: asyncio.streams.StreamReader,\n    writer: asyncio.streams.StreamWriter,\n    data: bytes,\n    peer: Optional[aioquic.asyncio.protocol.QuicConnectionProtocol] = None\n) -> None", "funcdef": "def"}, {"fullname": "p2p_tools.p2p_protocol.p2p_receive_package", "modulename": "p2p_tools.p2p_protocol", "qualname": "p2p_receive_package", "type": "function", "doc": "<p>This function is called when a peer expects a package of data from another peer. It will listen until it receives\na packet or until the aioquic timeout is reached. It will return the content of the received packet.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>reader</strong>:  The reader of the current stream.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The data-payload.</p>\n</blockquote>\n", "signature": "(\n    reader: asyncio.streams.StreamReader,\n    writer: asyncio.streams.StreamWriter,\n    peer: Optional[aioquic.asyncio.protocol.QuicConnectionProtocol] = None\n) -> Optional[bytes]", "funcdef": "async def"}, {"fullname": "p2p_tools.p2p_quic_connection", "modulename": "p2p_tools.p2p_quic_connection", "type": "module", "doc": "<p>This modul implements the managing of the QUIC connections. A QUIC connection disconnects after being a certain\ntime idle. The p2p_connect only establishes a new connection if the previous connection has expired. Otherwise, it\nreturns the already existing connection.</p>\n"}, {"fullname": "p2p_tools.p2p_quic_connection.P2PQuicConnection", "modulename": "p2p_tools.p2p_quic_connection", "qualname": "P2PQuicConnection", "type": "class", "doc": "<p>Implements a class that holds a QuicConnection. The aioquic library has a \"connect\" that must be used\nwith the \"async with\" construct. However, it cannot be used  within this application (since the \"async with\"\nconstruct limits the scope of the resulting QUIC connection to the associated code block).</p>\n"}, {"fullname": "p2p_tools.p2p_quic_connection.P2PQuicConnection.__init__", "modulename": "p2p_tools.p2p_quic_connection", "qualname": "P2PQuicConnection.__init__", "type": "function", "doc": "<p>Constructor for a P2PQuicConnection instance</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>host</strong>:  hostname or IP as string</li>\n<li><strong>port</strong>:  port number</li>\n<li><strong>configuration</strong>:  A QuicConfiguration dict</li>\n</ul>\n", "signature": "(\n    self,\n    host: str,\n    port: int,\n    configuration: aioquic.quic.configuration.QuicConfiguration\n)", "funcdef": "def"}, {"fullname": "p2p_tools.p2p_quic_connection.P2PQuicConnection.p2p_connect", "modulename": "p2p_tools.p2p_quic_connection", "qualname": "P2PQuicConnection.p2p_connect", "type": "function", "doc": "<p>This method does the actual connecting. A QUIC connection disconnects after a certain (configurable) time.\nThis method tries to avoid establishing new connections by checking if the last connection done is still\nactive. If so, this existing connection is returned. If not, a new connection is established.\nIn order to do so, the connection instance must be a _singleton_ for each connecting peer. This is\nhandled by the metaclass QuicConnectionSingleton.</p>\n\n<p>The P2PQuicConnection object also handles the streams used to transfer log data. In order to have only\none stream per log \u2013 a requirement for having consistent logs \u2013 streams are cached here per log. The\nmethod _p2p_init_log_streams_ <strong>must</strong> be used for creating streams for log data transfers. This method\nwill only create a new stream if there is no existing stream for this log.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>timeout</strong>:  Timeout when an idling connection gets disconnected</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a QUIC connection instance (aka QuicConnectionProtocol)</p>\n</blockquote>\n", "signature": "(\n    self,\n    timeout: float\n) -> aioquic.asyncio.protocol.QuicConnectionProtocol | None", "funcdef": "async def"}, {"fullname": "p2p_tools.p2p_quic_connection.P2PQuicConnection.p2p_disconnect", "modulename": "p2p_tools.p2p_quic_connection", "qualname": "P2PQuicConnection.p2p_disconnect", "type": "function", "doc": "<p>Disconnect from a peer and reset the log specific streams</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "(self) -> None", "funcdef": "async def"}, {"fullname": "p2p_tools.p2p_quic_connection.P2PQuicConnection.p2p_init_log_streams", "modulename": "p2p_tools.p2p_quic_connection", "qualname": "P2PQuicConnection.p2p_init_log_streams", "type": "function", "doc": "<p>Return an AOL specific reader/writer. If the log does not yet have a stream, it will be created.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>log_id</strong>:  ID of the AOL</li>\n<li><strong>sender_addr</strong>:  [optional] host of the sender</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Tuble of reader/writer for the stream</p>\n</blockquote>\n", "signature": "(\n    self,\n    log_id: str,\n    sender_addr: Optional[str] = None\n) -> Tuple[asyncio.streams.StreamReader, asyncio.streams.StreamWriter]", "funcdef": "async def"}, {"fullname": "p2p_tools.p2p_quic_connection.P2PQuicConnection.connection_obj", "modulename": "p2p_tools.p2p_quic_connection", "qualname": "P2PQuicConnection.connection_obj", "type": "variable", "doc": "<p>Getter for connection object</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>connection object</p>\n</blockquote>\n", "annotation": ": aioquic.asyncio.protocol.QuicConnectionProtocol"}, {"fullname": "p2p_tools.p2p_quic_connection.P2PQuicConnection.host", "modulename": "p2p_tools.p2p_quic_connection", "qualname": "P2PQuicConnection.host", "type": "variable", "doc": "<p>Getter for host</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Hostname</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "p2p_tools.p2p_quic_connection.P2PQuicConnection.port", "modulename": "p2p_tools.p2p_quic_connection", "qualname": "P2PQuicConnection.port", "type": "variable", "doc": "<p>Getter for port</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Port numner</p>\n</blockquote>\n", "annotation": ": int"}, {"fullname": "tools", "modulename": "tools", "type": "module", "doc": "<h1 id=\"module-tools\">Module \"tools\"</h1>\n\n<p>This module contains some common tool classes. Namely, there are</p>\n\n<ul>\n<li><strong>aol_singleton.py:</strong>\nThe singleton class for the AOL singleton. Within one peer, each AOL needs to be represented by\na singleton in order to guarantee consistency</li>\n<li><strong>quic_connection_singleton.py:</strong>\nthe quic connection singleton which guarantees that each AOL has one stream only to the\nfollowers the node is pushing information to</li>\n<li><strong>serializer.py</strong>:\nthe serializer which is used to serialize Python classes to JSON and vice versa</li>\n<li><strong>performance_measurer.py:</strong>\nA time measurement tool</li>\n</ul>\n"}, {"fullname": "tools.aol_singleton", "modulename": "tools.aol_singleton", "type": "module", "doc": "<p>Singleton metaclass for AppendOnlyLog class. Each AOL should have only one instance of the AppendOnlyLog-class\nper log in order to represent at any time a consistent state. This goal is achieved with following metaclass.</p>\n"}, {"fullname": "tools.aol_singleton.AOLSingleton", "modulename": "tools.aol_singleton", "qualname": "AOLSingleton", "type": "class", "doc": "<p>The idea for this class came from \"https://stackoverflow.com/questions/3615565/python-get-constructor-to-return-an-existing-object-instead-of-a-new-one\".\nThis class is used to create a singleton of the AppendOnlyLog class.</p>\n", "bases": "builtins.type"}, {"fullname": "tools.aol_singleton.AOLSingleton.__init__", "modulename": "tools.aol_singleton", "qualname": "AOLSingleton.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(cls, name, bases, attributes)", "funcdef": "def"}, {"fullname": "tools.performance_measurer", "modulename": "tools.performance_measurer", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tools.performance_measurer.Timer", "modulename": "tools.performance_measurer", "qualname": "Timer", "type": "class", "doc": "<p></p>\n"}, {"fullname": "tools.performance_measurer.Timer.__init__", "modulename": "tools.performance_measurer", "qualname": "Timer.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, name: str, report_calltime: Optional[bool] = False)", "funcdef": "def"}, {"fullname": "tools.performance_measurer.Timer.start_timer", "modulename": "tools.performance_measurer", "qualname": "Timer.start_timer", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "tools.performance_measurer.Timer.stop_timer", "modulename": "tools.performance_measurer", "qualname": "Timer.stop_timer", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "tools.performance_measurer.Timer.time", "modulename": "tools.performance_measurer", "qualname": "Timer.time", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "tools.performance_measurer.PerformanceMeasurer", "modulename": "tools.performance_measurer", "qualname": "PerformanceMeasurer", "type": "class", "doc": "<p></p>\n"}, {"fullname": "tools.performance_measurer.PerformanceMeasurer.__init__", "modulename": "tools.performance_measurer", "qualname": "PerformanceMeasurer.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, name: str)", "funcdef": "def"}, {"fullname": "tools.performance_measurer.PerformanceMeasurer.start_timer", "modulename": "tools.performance_measurer", "qualname": "PerformanceMeasurer.start_timer", "type": "function", "doc": "<p></p>\n", "signature": "(self, task: str, report_calltime: Optional[bool] = False)", "funcdef": "def"}, {"fullname": "tools.performance_measurer.PerformanceMeasurer.stop_timer", "modulename": "tools.performance_measurer", "qualname": "PerformanceMeasurer.stop_timer", "type": "function", "doc": "<p></p>\n", "signature": "(self, task: str)", "funcdef": "def"}, {"fullname": "tools.quic_connection_singleton", "modulename": "tools.quic_connection_singleton", "type": "module", "doc": "<p>Implements the QuicConnectionSingleton metaclass in order to create a single instance for the QUIC connections to the\npeers (e.g. to enforce one instance per connected peer). This is necessary to manage the keep_alive of connections\n(QUIC connections disconnect after a certain time) and in order to manage the log-specific streams (exactly one\nstream per log and peer is allowed in order to preserve the consistency of the logs)</p>\n"}, {"fullname": "tools.quic_connection_singleton.QuicConnectionSingleton", "modulename": "tools.quic_connection_singleton", "qualname": "QuicConnectionSingleton", "type": "class", "doc": "<p>The idea for this class came from \"https://stackoverflow.com/questions/3615565/python-get-constructor-to-return-an-existing-object-instead-of-a-new-one\".\nThis class is used to create a singleton of the AppendOnlyLog class.</p>\n", "bases": "builtins.type"}, {"fullname": "tools.quic_connection_singleton.QuicConnectionSingleton.__init__", "modulename": "tools.quic_connection_singleton", "qualname": "QuicConnectionSingleton.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(cls, name, bases, attributes)", "funcdef": "def"}, {"fullname": "tools.serializer", "modulename": "tools.serializer", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tools.serializer.serializer", "modulename": "tools.serializer", "qualname": "serializer", "type": "variable", "doc": "<p></p>\n", "default_value": " = <tools.serializer._Serializer object>"}, {"fullname": "peer_client", "modulename": "peer_client", "type": "module", "doc": "<p></p>\n"}, {"fullname": "peer_client.TaskBar", "modulename": "peer_client", "qualname": "TaskBar", "type": "class", "doc": "<p>Implements the taskbar</p>\n", "bases": "tkinter.ttk.Frame"}, {"fullname": "peer_client.LogsFrame", "modulename": "peer_client", "qualname": "LogsFrame", "type": "class", "doc": "<p>Implements the frame where the \"log-fino\" output is displayed</p>\n", "bases": "tkinter.ttk.Frame"}, {"fullname": "peer_client.LogsFrame.__init__", "modulename": "peer_client", "qualname": "LogsFrame.__init__", "type": "function", "doc": "<p>Constructor of log windows</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>parent</strong>:  parent frame</li>\n<li><strong>gui_api</strong>:  the G2PCommands instance</li>\n<li><strong>logs</strong>:  List of the AOL instances</li>\n<li><strong>write_to_userlog</strong>:  A callable to wrote to the \"userlog\"</li>\n<li><strong>audio_pipe</strong>:  The AudioPipe of the Audio interface</li>\n<li><strong>args</strong>:  additional positional parameters (e.g. tkinter things)</li>\n<li><strong>kwargs</strong>:  additional keyword parameter (e.g. tkinter things)</li>\n</ul>\n", "signature": "(\n    self,\n    parent,\n    gui_api: gui_client.g2p_commands.G2PCommands,\n    logs: List[aol.append_only_log.AppendOnlyLog],\n    write_to_userlog: Callable,\n    audio_pipe: gui_client.audio_pipe.AudioPipe,\n    *args,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "peer_client.LogsFrame.insert_new_log", "modulename": "peer_client", "qualname": "LogsFrame.insert_new_log", "type": "function", "doc": "<p>Insert new log</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>index</strong>: </li>\n<li><strong>elements</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self, index: Any, *elements: Any) -> None", "funcdef": "def"}, {"fullname": "peer_client.LogsFrame.add_text_entry", "modulename": "peer_client", "qualname": "LogsFrame.add_text_entry", "type": "function", "doc": "<p>add a new text entry to the selected log</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "peer_client.LogsFrame.add_audio_entry", "modulename": "peer_client", "qualname": "LogsFrame.add_audio_entry", "type": "function", "doc": "<p>Insert new audio entries. This method only calls a CreateAudioEntryDialog which does the rest</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "peer_client.LogsFrame.play_audio_entry", "modulename": "peer_client", "qualname": "LogsFrame.play_audio_entry", "type": "function", "doc": "<p>Play audio entries of the selected log. This method only calls the AudioPlayDialog which does the rest</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "peer_client.LogsFrame.clear_log", "modulename": "peer_client", "qualname": "LogsFrame.clear_log", "type": "function", "doc": "<p>Clears the userlog</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "peer_client.MainWindow", "modulename": "peer_client", "qualname": "MainWindow", "type": "class", "doc": "<p>Main window of peer client. It controls the complete gui application and offers the buttons to start the actions</p>\n\n<ul>\n<li>connect/disconnect with a peernode</li>\n<li>create a new log</li>\n<li>add an entry to an existing log</li>\n<li>add an audio message to an existing log</li>\n<li>initiate a bidirectional audio stream communication</li>\n<li>initiate a ping broadcast\nHas a feedback window where messages are displayed such as log created entry/received etc.</li>\n</ul>\n", "bases": "tkinter.ttk.Frame"}, {"fullname": "peer_client.MainWindow.__init__", "modulename": "peer_client", "qualname": "MainWindow.__init__", "type": "function", "doc": "<p>Constructor of the main window of the GUI</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>parent</strong>:  parent frame</li>\n<li><strong>gui_api</strong>:  instance of G2PCommands instance</li>\n<li><strong>args</strong>:  additional positional arguments</li>\n<li><strong>kwargs</strong>:  additional keyword parameters</li>\n</ul>\n", "signature": "(self, parent, gui_api, *args, **kwargs)", "funcdef": "def"}, {"fullname": "peer_client.MainWindow.create_menubar", "modulename": "peer_client", "qualname": "MainWindow.create_menubar", "type": "function", "doc": "<p>Creates a menu bar</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a menu bar</p>\n</blockquote>\n", "signature": "(self) -> tkinter.Menu", "funcdef": "def"}, {"fullname": "peer_client.MainWindow.connect", "modulename": "peer_client", "qualname": "MainWindow.connect", "type": "function", "doc": "<p>This methode connects the gui application with a peer. It first starts a dialog box where the ip address and port number of the peernode\ncan be entered. On ok, the connection is started. It is important to know that as soon as the connection is started, the tk.createfilehandler\nis called with the callback function that will process all incoming tcp data.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "peer_client.MainWindow.disconnect", "modulename": "peer_client", "qualname": "MainWindow.disconnect", "type": "function", "doc": "<p>Disconnect from the peer node</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "peer_client.MainWindow.ping", "modulename": "peer_client", "qualname": "MainWindow.ping", "type": "function", "doc": "<p>Send a Ping command to the peer node</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "peer_client.MainWindow.create_log", "modulename": "peer_client", "qualname": "MainWindow.create_log", "type": "function", "doc": "<p>Open a CreateLogDialog</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "peer_client.MainWindow.create_stream", "modulename": "peer_client", "qualname": "MainWindow.create_stream", "type": "function", "doc": "<p>Open a CreateAudioStreamDialog</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "peer_client.MainWindow.show_followers", "modulename": "peer_client", "qualname": "MainWindow.show_followers", "type": "function", "doc": "<p>Send a get followers command to the peer node</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "peer_client.MainWindow.write_to_userlog", "modulename": "peer_client", "qualname": "MainWindow.write_to_userlog", "type": "function", "doc": "<p>This function is used to write into the logging-window of the GUI.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>msg</strong>:  The text that should be written to the GUI widget</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self, msg) -> None", "funcdef": "def"}, {"fullname": "peer_client.MainWindow.socket_callback", "modulename": "peer_client", "qualname": "MainWindow.socket_callback", "type": "function", "doc": "<p>This callback is called by the tkinter event loop when there is input to be read from the socket.\n<strong>All</strong> communication <strong>from</strong> the peer is processed by this callback. Thus, both \"expected\" as \"out-of-band\"\nmessages from the peer node can be processed by the GUI!</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>sock</strong>:  The socket where there is data to be read</li>\n<li><strong>mask</strong>:  Not used</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self, sock: socket.socket, mask: int) -> None", "funcdef": "def"}, {"fullname": "peer_client.App", "modulename": "peer_client", "qualname": "App", "type": "class", "doc": "<p>Main frame for tkinter of the GUI</p>\n", "bases": "tkinter.Tk"}, {"fullname": "peer_client.App.__init__", "modulename": "peer_client", "qualname": "App.__init__", "type": "function", "doc": "<p>Return a new Toplevel widget on screen SCREENNAME. A new Tcl interpreter will\nbe created. BASENAME will be used for the identification of the profile file (see\nreadprofile).\nIt is constructed from sys.argv[0] without extensions if None is given. CLASSNAME\nis the name of the widget class.</p>\n", "signature": "(self, title, *args, **kwargs)", "funcdef": "def"}, {"fullname": "peer_node", "modulename": "peer_node", "type": "module", "doc": "<p>Main modul which implements the main program for the peer</p>\n"}, {"fullname": "peer_node.PeerNode", "modulename": "peer_node", "qualname": "PeerNode", "type": "class", "doc": "<p>Main class that implements a peer node. A peer node communicates with other peer nodes using the QUIC protocol.\nA user accesses it's peer node using a simple TCP-connection that eventually implements a GUI. As such the peer\nnode may run headless, e.g. in a docker container or on a server without GUI.</p>\n\n<p>The peer node reacts to requests from the gui comming in over a tcp socket and to request/p2p_commands from other peers\ncomming in from QUIC connections. The tcp requests are handled in \"self.handle_tcp_request\". In there the gui\ncommand (GuiCommands) is determined and the handler methode is taken from the dict \"self._g2p_tcp_handler\". This\ndict must have handlers for all possible gui p2p_commands. The incoming QUIC requests are handled in\n\"self._currentstreamhandler\". The command object is deserialized from the incoming json and its action method is\ncalled. Therefore we do not have to have an if/elif/else chain to determine the correct action. The incoming object\nhas already the correct action methode.</p>\n"}, {"fullname": "peer_node.PeerNode.__init__", "modulename": "peer_node", "qualname": "PeerNode.__init__", "type": "function", "doc": "<p>Initializes a peer_node. The peer node belongs to a user that connect's himself via a gui, that works over\na tcp connection, to the peer_node. Via the gui, p2p_commands are sent to the peer_node which are executed by the\npeer_node.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>peerhost</strong>:  The hostname/IP of this peer_node (QUIC)</li>\n<li><strong>peerport</strong>:  The port of this peer_node (QUIC)</li>\n<li><strong>guihost</strong>:  The hostname/IP of the gui interface to connect to (TCP)</li>\n<li><strong>guiport</strong>:  The port of the gui interface to connect to (TCP)</li>\n<li><strong>followers: A list of followers of this particular node. A follower has the form: host</strong>: port.</li>\n<li><strong>following</strong>:  A list of peers this peer is following actively</li>\n</ul>\n", "signature": "(\n    self,\n    peerhost: str,\n    peerport: int,\n    guihost: str,\n    guiport: int,\n    ttl: int,\n    followers: Optional[List[str]] = None,\n    following: Optional[List[str]] = None\n)", "funcdef": "def"}, {"fullname": "peer_node.PeerNode.start_connections", "modulename": "peer_node", "qualname": "PeerNode.start_connections", "type": "function", "doc": "<p>Activates the node and everything that belongs to it.</p>\n\n<ol>\n<li>starts quic server</li>\n<li>connects to all followers and followings</li>\n<li>exchanges frontiers with followers and followings\nWhen start_connections is done, the node is up to date and active</li>\n</ol>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>timeout</strong>:  Time after that the connection quits</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self, timeout: float) -> None", "funcdef": "async def"}, {"fullname": "peer_node.PeerNode.my_addr", "modulename": "peer_node", "qualname": "PeerNode.my_addr", "type": "variable", "doc": "<p>A getter function that returns the address and port of this particular peer-instance. Its returned in the form:\n\"host\":\"port\"</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>str</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "peer_node.PeerNode.get_frontiers", "modulename": "peer_node", "qualname": "PeerNode.get_frontiers", "type": "function", "doc": "<p>A methode that calculates and returns the frontier of self.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A list of frontiers</p>\n</blockquote>\n", "signature": "(self) -> List[p2p_commands.frontier.Frontier]", "funcdef": "def"}, {"fullname": "peer_node.PeerNode.start_tcpserver", "modulename": "peer_node", "qualname": "PeerNode.start_tcpserver", "type": "function", "doc": "<p>This method starts the tcp server that's listening on the given port for connection from a GUI-client.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>host</strong>:  Host of peer-node</li>\n<li><strong>port</strong>:  Port the peer node is listening for connection from a GUI client</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self, host: str, port: int) -> None", "funcdef": "async def"}, {"fullname": "peer_node.PeerNode.handle_tcp_request", "modulename": "peer_node", "qualname": "PeerNode.handle_tcp_request", "type": "function", "doc": "<p>This method handles all the tcp requests that get send by the gui to this peer. This peer is the \"self\" peer,\nthe originating peer, the user utilizes for communicating with other peers. Normally the gui sends p2p_commands\nand receives results (of the sent p2p_commands).</p>\n\n<p>The handle_tcp_request methode is automatically called by the asyncio loop with the given reader and writer of the tcp connection. Thus i have\nonly access to the tcp reader/writer within this methode. If the aioquic loop requires something to the gui, this imformation has to be\ntransferred in this methode. This is done using a future.</p>\n\n<p>In essence i've got two seperate while loops that need to interact with each other. The while loop of the aioquic that wants to send data to\nthe gui and this loop that listens to incomming commands from the gui. With the \"wait_for_first\" it can be listened to both sides.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>reader</strong>:  The reader of the socket connection between gui and peer_node</li>\n<li><strong>writer</strong>:  The writer of the socket connection between gui and peer_node</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    self,\n    reader: asyncio.streams.StreamReader,\n    writer: asyncio.streams.StreamWriter\n) -> None", "funcdef": "async def"}, {"fullname": "peer_node.PeerNode.g2p_ping_handler", "modulename": "peer_node", "qualname": "PeerNode.g2p_ping_handler", "type": "function", "doc": "<p>Gets called when the gui emmits a ping command to the peer</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>reader</strong>:  TCP reader of peer node</li>\n<li><strong>writer</strong>:  TCP writer of peer node</li>\n<li><strong>wait_for_first</strong>:  Is given from handle_tcp_request so that the task can be rearmed after this request has been processed</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    self,\n    reader: asyncio.streams.StreamReader,\n    writer: asyncio.streams.StreamWriter,\n    wait_for_first: Set[_asyncio.Future | _asyncio.Task]\n) -> None", "funcdef": "async def"}, {"fullname": "peer_node.PeerNode.p2g_ping_handler", "modulename": "peer_node", "qualname": "PeerNode.p2g_ping_handler", "type": "function", "doc": "<p>Gets called when the peer receives a ping answer. It sends the ping info to the GUI</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>answer</strong>:  Answer of the ping request</li>\n<li><strong>writer</strong>:  TCP writer</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    self,\n    answer: p2p_commands.abstract_p2p_command.AbstractP2PCommand,\n    writer: asyncio.streams.StreamWriter\n) -> None", "funcdef": "async def"}, {"fullname": "peer_node.PeerNode.p2g_log_push_handler", "modulename": "peer_node", "qualname": "PeerNode.p2g_log_push_handler", "type": "function", "doc": "<p>Gets called when the peer gets a log push command. It sends the info of the newly created log to the Gio</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>answer</strong>:  Info about the log</li>\n<li><strong>writer</strong>:  TCP writer</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    self,\n    answer: p2p_commands.abstract_p2p_command.AbstractP2PCommand,\n    writer: asyncio.streams.StreamWriter\n) -> None", "funcdef": "async def"}, {"fullname": "peer_node.PeerNode.p2g_following_handler", "modulename": "peer_node", "qualname": "PeerNode.p2g_following_handler", "type": "function", "doc": "<p>Gets called when the peer gets a following message. It sends the info to the GUI</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>answer</strong>:  Info about the following peer</li>\n<li><strong>writer</strong>:  TCP writer</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    self,\n    answer: p2p_commands.abstract_p2p_command.AbstractP2PCommand,\n    writer: asyncio.streams.StreamWriter\n) -> None", "funcdef": "async def"}, {"fullname": "peer_node.PeerNode.g2p_and_p2g_create_log_handler", "modulename": "peer_node", "qualname": "PeerNode.g2p_and_p2g_create_log_handler", "type": "function", "doc": "<p>Gets called when the gui emits a CreateLogCommand to the peer. The handler creates the log file and sends a\nresponse to the gui immediately</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>reader</strong>:  TCP reader</li>\n<li><strong>writer</strong>:  TCP writer</li>\n<li><strong>wait_for_first</strong>:  Is given from handle_tcp_request so that the task can be rearmed after this request\n                   has been processed</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    self,\n    reader: asyncio.streams.StreamReader,\n    writer: asyncio.streams.StreamWriter,\n    wait_for_first: Set[_asyncio.Future | _asyncio.Task]\n) -> None", "funcdef": "async def"}, {"fullname": "peer_node.PeerNode.g2p_and_p2g_create_log_entry_handler", "modulename": "peer_node", "qualname": "PeerNode.g2p_and_p2g_create_log_entry_handler", "type": "function", "doc": "<p>Gets called when the gui emmits a CreateLogEntryCommand to the peer. The handler creates the entry and sends a response to the gui immediately</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>reader</strong>:  TCP reader</li>\n<li><strong>writer</strong>:  TCP writer</li>\n<li><strong>wait_for_first</strong>:  Is given from handle_tcp_request so that the task can be rearmed after this request has been processed</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    self,\n    reader: asyncio.streams.StreamReader,\n    writer: asyncio.streams.StreamWriter,\n    wait_for_first: Set[_asyncio.Future | _asyncio.Task]\n) -> None", "funcdef": "async def"}, {"fullname": "peer_node.PeerNode.g2p_and_p2g_get_log_entry_handler", "modulename": "peer_node", "qualname": "PeerNode.g2p_and_p2g_get_log_entry_handler", "type": "function", "doc": "<p>Gets called when the gui emits a GetLogEntryCommand to the peer. The handler fetches the entry given in the command and sends it back to\nthe gui immediately</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>reader</strong>:  TCP reader</li>\n<li><strong>writer</strong>:  TCP writer</li>\n<li><strong>wait_for_first</strong>:  Is given from handle_tcp_request so that the task can be rearmed after this request has been processed</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    self,\n    reader: asyncio.streams.StreamReader,\n    writer: asyncio.streams.StreamWriter,\n    wait_for_first: Set[_asyncio.Future | _asyncio.Task]\n) -> None", "funcdef": "async def"}, {"fullname": "peer_node.PeerNode.g2p_and_p2g_get_followers_handler", "modulename": "peer_node", "qualname": "PeerNode.g2p_and_p2g_get_followers_handler", "type": "function", "doc": "<p>Gets called when the GUI issues a \"get followers\" command. Sends the list of active followers to the GUI</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>reader</strong>:  TCP reader</li>\n<li><strong>writer</strong>:  TCP writer</li>\n<li><strong>wait_for_first</strong>:  Is given from handle_tcp_request so that the task can be rearmed after this request has been processed</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(\n    self,\n    reader: asyncio.streams.StreamReader,\n    writer: asyncio.streams.StreamWriter,\n    wait_for_first: Set[_asyncio.Future | _asyncio.Task]\n) -> None", "funcdef": "async def"}, {"fullname": "peer_node.PeerNode.start_quicserver", "modulename": "peer_node", "qualname": "PeerNode.start_quicserver", "type": "function", "doc": "<p>This method starts the QUIC-server of the current peer_node. It listens to QUIC-connects from other peers\nand reacts to the P2PCommands received.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self) -> None", "funcdef": "async def"}, {"fullname": "peer_node.PeerNode.push_info_to_following", "modulename": "peer_node", "qualname": "PeerNode.push_info_to_following", "type": "function", "doc": "<p>Send the info that this peer is following to the respective peers</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self) -> None", "funcdef": "async def"}, {"fullname": "peer_node.PeerNode.check_following_not_active", "modulename": "peer_node", "qualname": "PeerNode.check_following_not_active", "type": "function", "doc": "<p>This coroutine must be run as a background task. It checks periodically if the peers this node is following\nbut are marked as \"inactive\" got active in the meantime. If a peer is detected that got active, it's frontier\nis being pulled to make this node up-to-date. In addition, this node also pushed it's (new) frontier to\nall his followers</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>interval</strong>:  Interval in seconds this coroutine becomes active</li>\n</ul>\n", "signature": "(self, interval: float) -> None", "funcdef": "async def"}, {"fullname": "peer_node.PeerNode.pull_frontier", "modulename": "peer_node", "qualname": "PeerNode.pull_frontier", "type": "function", "doc": "<p>This methode is only called when a node newly (re-)enters the network\nThis methods requests all new entries and logs (frontiers) from the nodes I'm following</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self) -> None", "funcdef": "async def"}, {"fullname": "peer_node.PeerNode.background_noise", "modulename": "peer_node", "qualname": "PeerNode.background_noise", "type": "function", "doc": "<p>This is a task which emitts a P2PNoise package and then waits a random time (with a maximum waiting\ntime given as paremeter). The payload is a random chunk of random bytes (with a length between 16 and 512\nbytes).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>maxinterval</strong>:  Maximum waiting time before emitting the next package</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self, maxinterval: float) -> None", "funcdef": "async def"}, {"fullname": "peer_node.PeerNode.shutdown", "modulename": "peer_node", "qualname": "PeerNode.shutdown", "type": "function", "doc": "<p>Shutdown the node properly. It sends a cancel to all pending tasks and waits these tasks to be\nfinished. Thus a shutdwon may take some time.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self) -> None", "funcdef": "async def"}, {"fullname": "peer_node.PeerNode.shutdown_from_signal", "modulename": "peer_node", "qualname": "PeerNode.shutdown_from_signal", "type": "function", "doc": "<p>We got a signal to stop the node. Is used for the docker</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>args</strong>:  positional arguments</li>\n<li><strong>kwargs</strong>:  keyword arguments</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self, *args, **kwargs) -> None", "funcdef": "def"}, {"fullname": "peer_node.PeerNode.node_start", "modulename": "peer_node", "qualname": "PeerNode.node_start", "type": "function", "doc": "<p>This function is the wrapper function, that starts all the functionalities of the peer_node concurrently.\nIt is in a sense the \"main\" function, of the peer_node.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "(self, noisefrequency: float = 0.0) -> None", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();